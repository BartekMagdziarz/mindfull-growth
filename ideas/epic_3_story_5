Story 5 – Journal Editor Chat Button & Navigation

Goal

Add a "Chat" button to the Journal Editor's bottom action bar with a dropdown menu for selecting chat intentions. Implement the logic to save the entry and navigate to the chat view when a chat intention is selected. This story establishes the entry point for the chat feature, allowing users to initiate conversations about their journal entries.

⸻

Scope

	1.	Chat Button UI Component
	•	Update `src/views/JournalEditorView.vue` to add a "Chat" button in the bottom action bar:
	•	Position: Place the Chat button to the left of the Cancel button (between the content area and Cancel button).
	•	Styling: Use the AppButton component with "text" variant (or "outlined" variant, consistent with Cancel button style).
	•	Button text: "Chat" (simple and clear).
	•	Icon (optional): Consider adding a chat/comment icon from Heroicons (e.g., ChatBubbleLeftRightIcon) to make the button more visually distinct.
	•	Disabled state: The Chat button should be disabled when:
	•	The entry body is empty (same validation as Save button: `body.value.trim().length === 0`).
	•	The entry is currently being saved (`isSaving.value === true`).
	•	Use the same disabled logic pattern as the Save button for consistency.
	•	Accessibility:
	•	Add appropriate ARIA labels: `aria-label="Start chat about this entry"` or similar.
	•	Ensure keyboard navigation works correctly (Tab order: Chat → Cancel → Save).
	•	Button should be focusable and keyboard accessible.

	2.	Chat Intention Dropdown Menu
	•	Implement a dropdown menu that appears when the Chat button is clicked:
	•	UI Pattern: Use a dropdown/menu component or implement a custom dropdown using Vue's conditional rendering.
	•	Options: Display the five available chat intentions:
	•	"Reflect" – with description: "Explore deeper meanings and patterns"
	•	"Help see differently" – with description: "Consider alternative perspectives"
	•	"Help to be proactive" – with description: "Identify actionable steps"
	•	"Thinking traps" – with description: "Identify cognitive distortions"
	•	"Custom" – with description: "Use your own prompt"
	•	Menu Structure:
	•	Each option should be clickable and clearly labeled.
	•	Show brief descriptions for each intention (as shown above) to help users understand what each option does.
	•	Visual design: Use consistent styling with the app (AppCard or similar for the dropdown container).
	•	Positioning: Dropdown should appear below or above the Chat button (preferably below, but adjust if space is limited).
	•	Close on selection: When a user clicks an intention, the dropdown should close and the chat flow should begin.
	•	Close on outside click: Clicking outside the dropdown should close it without starting a chat.
	•	Keyboard navigation: Support arrow keys to navigate options, Enter to select, Escape to close.
	•	Custom Prompt Input (for "Custom" intention):
	•	When "Custom" is selected, show an input field or dialog for the user to enter their custom prompt.
	•	Input field should be a textarea (to allow multi-line prompts).
	•	Label: "Enter your custom prompt" or "What would you like to explore?"
	•	Placeholder: "E.g., Help me understand why I feel anxious about this situation..."
	•	Validation: Custom prompt should not be empty (show error if user tries to proceed with empty prompt).
	•	Buttons: "Start Chat" and "Cancel" buttons in the custom prompt dialog.
	•	If user cancels, return to the dropdown menu (or close the dropdown).
	•	If user confirms, proceed with the chat flow using the custom prompt.

	3.	Chat Intention Constants & Types
	•	Import or reference the chat intention constants from Story 4:
	•	Import `CHAT_INTENTIONS` from `src/services/chatPrompts.ts` (or wherever it's defined).
	•	Import `ChatIntention` type from `src/domain/chatSession.ts`.
	•	Create a local constant array for the dropdown menu options:
	•	```typescript
	•	const chatIntentionOptions = [
	•	  {
	•	    value: CHAT_INTENTIONS.REFLECT,
	•	    label: "Reflect",
	•	    description: "Explore deeper meanings and patterns"
	•	  },
	•	  {
	•	    value: CHAT_INTENTIONS.HELP_SEE_DIFFERENTLY,
	•	    label: "Help see differently",
	•	    description: "Consider alternative perspectives"
	•	  },
	•	  {
	•	    value: CHAT_INTENTIONS.PROACTIVE,
	•	    label: "Help to be proactive",
	•	    description: "Identify actionable steps"
	•	  },
	•	  {
	•	    value: CHAT_INTENTIONS.THINKING_TRAPS,
	•	    label: "Thinking traps",
	•	    description: "Identify cognitive distortions"
	•	  },
	•	  {
	•	    value: CHAT_INTENTIONS.CUSTOM,
	•	    label: "Custom",
	•	    description: "Use your own prompt"
	•	  }
	•	] as const
	•	```
	•	This ensures consistency with the chat store and domain models.

	4.	Save-and-Navigate Logic
	•	Implement the `handleChat` function (or similar) that:
	•	Validates that the entry body is not empty (same validation as Save button).
	•	If validation fails, show an error message (e.g., "Please enter some content before starting a chat.") and return early.
	•	Saves the entry first (using the same save logic as `handleSave`):
	•	If in edit mode: Update the existing entry using `journalStore.updateEntry()`.
	•	If in create mode: Create a new entry using `journalStore.createEntry()`.
	•	Wait for the save operation to complete before proceeding.
	•	Handle save errors gracefully:
	•	If save fails, show an error message and stay on the editor page (don't navigate to chat).
	•	After successful save:
	•	Get the entry ID (either from `currentEntry.value.id` in edit mode, or from the newly created entry's ID).
	•	Store the selected chat intention and optional custom prompt (if "Custom" was selected).
	•	Navigate to the chat view: `router.push(`/journal/${entryId}/chat`)`.
	•	Pass the intention and custom prompt via route params or query params, or use the chat store to set them before navigation.
	•	Note: The chat view route and component will be implemented in Story 6, so for now the navigation will go to a route that doesn't exist yet. This is acceptable for Story 5.
	•	Loading state: Show a loading indicator on the Chat button while saving (similar to how Save button shows "Saving...").
	•	Disable the Chat button during the save operation to prevent multiple clicks.

	5.	Chat Store Integration
	•	Import the chat store: `import { useChatStore } from '@/stores/chat.store'`.
	•	In the component, initialize the chat store: `const chatStore = useChatStore()`.
	•	Before navigating to the chat view, initialize the chat session in the store:
	•	Call `chatStore.startChatSession(entryId, intention, customPrompt?)` with:
	•	entryId: The ID of the saved journal entry.
	•	intention: The selected chat intention (e.g., "reflect", "help-see-differently", etc.).
	•	customPrompt: The custom prompt string (only if intention is "custom").
	•	This ensures the chat view has the session ready when it loads.
	•	Handle errors from `startChatSession`:
	•	If starting the session fails, show an error message and don't navigate.
	•	Note: The chat store's `startChatSession` should be lightweight (just creates the session object in memory), so errors are unlikely, but handle them gracefully.

	6.	State Management for Dropdown
	•	Add reactive state for managing the dropdown menu:
	•	`const showChatDropdown = ref(false)` – controls dropdown visibility.
	•	`const showCustomPromptDialog = ref(false)` – controls custom prompt input dialog visibility.
	•	`const customPromptInput = ref('')` – stores the user's custom prompt text.
	•	Functions:
	•	`openChatDropdown()` – sets `showChatDropdown.value = true`.
	•	`closeChatDropdown()` – sets `showChatDropdown.value = false`.
	•	`openCustomPromptDialog()` – closes dropdown, opens custom prompt dialog.
	•	`closeCustomPromptDialog()` – closes custom prompt dialog.
	•	`handleIntentionSelection(intention: ChatIntention)` – handles when user selects an intention:
	•	If intention is "custom", open the custom prompt dialog.
	•	Otherwise, proceed directly to the chat flow (save and navigate).
	•	`handleCustomPromptConfirm()` – validates custom prompt and proceeds to chat flow.
	•	Click outside handler: Add an event listener (or use Vue's `@click.outside` directive if available) to close the dropdown when clicking outside.
	•	Escape key handler: Add keyboard event listener to close dropdown on Escape key press.

	7.	UI/UX Enhancements
	•	Visual feedback:
	•	Show a loading state on the Chat button while saving ("Saving..." or spinner icon).
	•	Disable all action buttons (Chat, Cancel, Save) while saving to prevent conflicting operations.
	•	Error handling:
	•	Show user-friendly error messages using the AppSnackbar component (already used in the component).
	•	Error messages should be clear and actionable (e.g., "Please enter some content before starting a chat.").
	•	Accessibility:
	•	Ensure the dropdown menu is keyboard accessible (Tab, Arrow keys, Enter, Escape).
	•	Add proper ARIA attributes to the dropdown menu (role="menu", role="menuitem", etc.).
	•	Ensure screen readers can announce the dropdown options correctly.
	•	Responsive design:
	•	Ensure the dropdown menu works well on mobile devices (consider using a modal/dialog on small screens if needed).
	•	Test the layout on different screen sizes to ensure buttons and dropdown are accessible.

	8.	Component Tests
	•	Add comprehensive component tests (Vitest with Vue Test Utils) for:
	•	Chat Button Rendering:
	•	Test that the Chat button is rendered in the bottom action bar.
	•	Test that the Chat button is positioned correctly (to the left of Cancel button).
	•	Test that the Chat button has correct styling and variant.
	•	Chat Button Disabled State:
	•	Test that Chat button is disabled when body is empty.
	•	Test that Chat button is disabled when entry is being saved.
	•	Test that Chat button is enabled when body has content and not saving.
	•	Dropdown Menu:
	•	Test that clicking Chat button opens the dropdown menu.
	•	Test that dropdown shows all five intention options with correct labels and descriptions.
	•	Test that clicking outside the dropdown closes it.
	•	Test that pressing Escape closes the dropdown.
	•	Test keyboard navigation (arrow keys, Enter, Escape).
	•	Intention Selection:
	•	Test that selecting a non-custom intention (e.g., "Reflect") closes dropdown and triggers save-and-navigate flow.
	•	Test that selecting "Custom" opens the custom prompt dialog.
	•	Custom Prompt Dialog:
	•	Test that custom prompt dialog appears when "Custom" is selected.
	•	Test that custom prompt input field is present and functional.
	•	Test that "Start Chat" button is disabled when custom prompt is empty.
	•	Test that "Start Chat" button is enabled when custom prompt has content.
	•	Test that "Cancel" button closes the dialog without starting chat.
	•	Test that confirming with a valid custom prompt proceeds to chat flow.
	•	Save-and-Navigate Flow:
	•	Test that selecting an intention saves the entry first (in create mode).
	•	Test that selecting an intention updates the entry first (in edit mode).
	•	Test that after successful save, navigation occurs to `/journal/:id/chat` with correct entry ID.
	•	Test that if save fails, navigation does not occur and error message is shown.
	•	Test that Chat button shows loading state during save operation.
	•	Chat Store Integration:
	•	Test that `chatStore.startChatSession` is called with correct parameters (entryId, intention, customPrompt).
	•	Test that if `startChatSession` fails, error is shown and navigation does not occur.
	•	Error Scenarios:
	•	Test that clicking Chat with empty body shows validation error and does not save/navigate.
	•	Test that save errors are handled gracefully (error message shown, no navigation).
	•	Test that network errors during save are handled correctly.
	•	Use mocking for:
	•	Router (mock `router.push`).
	•	Journal store (mock `createEntry` and `updateEntry`).
	•	Chat store (mock `startChatSession`).
	•	Follow existing test patterns in `src/views/__tests__/JournalEditorView.spec.ts`.
	•	Use descriptive test names that explain what is being tested.

⸻

Acceptance Criteria

	•	Chat Button:
	•	Chat button is rendered in the bottom action bar, positioned to the left of the Cancel button.
	•	Chat button uses AppButton component with appropriate variant and styling.
	•	Chat button is disabled when entry body is empty (same validation as Save button).
	•	Chat button is disabled when entry is being saved.
	•	Chat button is enabled when body has content and not saving.
	•	Chat button has appropriate ARIA labels and is keyboard accessible.
	•	Dropdown Menu:
	•	Clicking Chat button opens a dropdown menu showing all five chat intentions.
	•	Each intention option displays correct label and description.
	•	Dropdown can be closed by clicking outside, pressing Escape, or selecting an option.
	•	Dropdown supports keyboard navigation (arrow keys, Enter, Escape).
	•	Custom Prompt Dialog:
	•	Selecting "Custom" intention opens a dialog with textarea input for custom prompt.
	•	Custom prompt input has appropriate label and placeholder.
	•	"Start Chat" button is disabled when custom prompt is empty.
	•	"Start Chat" button is enabled when custom prompt has content.
	•	"Cancel" button closes dialog without starting chat.
	•	Save-and-Navigate Logic:
	•	Selecting an intention validates entry body (shows error if empty).
	•	Selecting an intention saves the entry first (create or update as appropriate).
	•	After successful save, navigates to `/journal/:id/chat` with correct entry ID.
	•	If save fails, shows error message and does not navigate.
	•	Chat button shows loading state during save operation.
	•	Chat Store Integration:
	•	`chatStore.startChatSession` is called with correct parameters before navigation.
	•	If `startChatSession` fails, error is shown and navigation does not occur.
	•	Error Handling:
	•	All errors show user-friendly messages via AppSnackbar.
	•	Validation errors prevent save/navigation.
	•	Save errors are handled gracefully.
	•	The app can be started and:
	•	Journal Editor displays Chat button in bottom action bar.
	•	Users can click Chat button to see intention options.
	•	Users can select an intention and the entry is saved and navigation occurs (to a route that will be implemented in Story 6).
	•	Users can enter a custom prompt for "Custom" intention.
	•	Component tests for Chat button and dropdown pass.
	•	Linting and TypeScript checks pass with no new errors.

⸻

Out of Scope

	•	Chat view component implementation (will be implemented in Stories 6 and 7).
	•	Chat view route definition (will be implemented in Story 6, though the route path should be known: `/journal/:id/chat`).
	•	Actual chat conversation functionality (will be implemented in Story 7).
	•	Chat session persistence UI (will be implemented in Story 8).
	•	Chat history display in journal editor (will be implemented in Story 9).
	•	Advanced dropdown animations or transitions (basic show/hide is sufficient for MVP).
	•	Dropdown positioning logic for edge cases (basic positioning is sufficient).
	•	Custom prompt templates or saved prompts (out of scope for this epic).
	•	Multiple chat sessions per entry selection (users can start multiple chats by clicking Chat button multiple times, but selection UI is not needed for MVP).

⸻

Technical Considerations

	•	Dropdown Implementation Options:
	•	Option A: Use a third-party dropdown/menu component (if the app already uses one).
	•	Option B: Implement a custom dropdown using Vue's conditional rendering and positioning.
	•	Option C: Use a modal/dialog for the intention selection (especially on mobile).
	•	Recommendation: Start with Option B (custom dropdown) for MVP, as it's simpler and doesn't require additional dependencies. Can be enhanced later if needed.
	•	Custom Prompt Dialog:
	•	Consider using AppDialog component (if it exists) for the custom prompt input, or implement a simple modal overlay.
	•	The dialog should be accessible (keyboard navigation, focus management, ARIA attributes).
	•	Route Parameter Passing:
	•	Option A: Pass intention and customPrompt via route query params (e.g., `/journal/:id/chat?intention=reflect&customPrompt=...`).
	•	Option B: Store intention and customPrompt in chat store before navigation (recommended, as it's cleaner and doesn't expose data in URL).
	•	Option C: Pass via route state (Vue Router's state feature).
	•	Recommendation: Use Option B (chat store) as it's cleaner and the data is already being set there via `startChatSession`.
	•	Save Logic Reuse:
	•	The save logic in `handleChat` should be very similar to `handleSave`, but without the navigation to `/journal`.
	•	Consider extracting the save logic into a shared function to avoid code duplication:
	•	```typescript
	•	async function saveEntry(): Promise<JournalEntry | null> {
	•	  // Validation
	•	  if (!body.value.trim()) {
	•	    throw new Error('Please enter some content for your journal entry.')
	•	  }
	•	  
	•	  const payload = { ... }
	•	  
	•	  if (isEditMode.value && currentEntry.value) {
	•	    return await journalStore.updateEntry({ ...currentEntry.value, ...payload })
	•	  } else {
	•	    return await journalStore.createEntry(payload)
	•	  }
	•	}
	•	```
	•	Then both `handleSave` and `handleChat` can call this function.
	•	State Management:
	•	Keep dropdown and dialog state local to the component (using `ref`).
	•	Don't store dropdown state in a global store (it's UI state, not application state).
	•	Error Handling:
	•	All errors should be caught and displayed to the user via AppSnackbar.
	•	Don't let unhandled errors crash the component or prevent the UI from being usable.
	•	Loading States:
	•	Ensure that during save operations, all action buttons are disabled to prevent conflicting operations.
	•	Show clear loading feedback to the user.
	•	Testing Strategy:
	•	Mock all external dependencies (router, stores, repositories).
	•	Test user interactions (clicks, keyboard events) thoroughly.
	•	Test both success and error scenarios.
	•	Test edge cases (empty body, save failures, etc.).
	•	Follow existing test patterns in the codebase.

⸻

Implementation Notes

	•	Component Structure:
	•	Add the Chat button in the bottom action bar section (around line 159-173 in JournalEditorView.vue):
	•	```vue
	•	<!-- Bottom Action Bar -->
	•	<div class="sticky bottom-0 left-0 right-0 bg-background border-t border-outline/30 flex justify-end gap-3 px-2 sm:px-4 py-4">
	•	  <!-- Chat Button with Dropdown -->
	•	  <div class="relative" v-if="!isLoading">
	•	    <AppButton
	•	      variant="text"
	•	      @click="openChatDropdown"
	•	      :disabled="!canStartChat"
	•	      aria-label="Start chat about this entry"
	•	    >
	•	      Chat
	•	    </AppButton>
	•	    
	•	    <!-- Dropdown Menu -->
	•	    <div
	•	      v-if="showChatDropdown"
	•	      class="absolute bottom-full left-0 mb-2 w-64 rounded-lg border border-outline/30 bg-surface shadow-elevation-3 p-2 z-50"
	•	      role="menu"
	•	    >
	•	      <button
	•	        v-for="option in chatIntentionOptions"
	•	        :key="option.value"
	•	        @click="handleIntentionSelection(option.value)"
	•	        class="w-full text-left px-4 py-3 rounded-lg hover:bg-surface-variant transition-colors"
	•	        role="menuitem"
	•	      >
	•	        <div class="font-medium text-on-surface">{{ option.label }}</div>
	•	        <div class="text-sm text-on-surface-variant">{{ option.description }}</div>
	•	      </button>
	•	    </div>
	•	  </div>
	•	  
	•	  <AppButton variant="text" @click="handleCancel" :disabled="isSaving">
	•	    Cancel
	•	  </AppButton>
	•	  <AppButton ... >Save</AppButton>
	•	</div>
	•	```
	•	Script Setup Additions:
	•	```typescript
	•	import { useChatStore } from '@/stores/chat.store'
	•	import { CHAT_INTENTIONS } from '@/services/chatPrompts'
	•	import type { ChatIntention } from '@/domain/chatSession'
	•	
	•	const chatStore = useChatStore()
	•	const showChatDropdown = ref(false)
	•	const showCustomPromptDialog = ref(false)
	•	const customPromptInput = ref('')
	•	const isStartingChat = ref(false)
	•	
	•	const canStartChat = computed(() => {
	•	  return body.value.trim().length > 0 && !isSaving.value && !isStartingChat.value
	•	})
	•	
	•	const chatIntentionOptions = [
	•	  {
	•	    value: CHAT_INTENTIONS.REFLECT,
	•	    label: "Reflect",
	•	    description: "Explore deeper meanings and patterns"
	•	  },
	•	  // ... other options
	•	] as const
	•	
	•	function openChatDropdown() {
	•	  showChatDropdown.value = true
	•	}
	•	
	•	function closeChatDropdown() {
	•	  showChatDropdown.value = false
	•	}
	•	
	•	async function handleIntentionSelection(intention: ChatIntention) {
	•	  closeChatDropdown()
	•	  
	•	  if (intention === CHAT_INTENTIONS.CUSTOM) {
	•	    showCustomPromptDialog.value = true
	•	  } else {
	•	    await startChat(intention)
	•	  }
	•	}
	•	
	•	async function startChat(intention: ChatIntention, customPrompt?: string) {
	•	  // Validation
	•	  if (!body.value.trim()) {
	•	    snackbarRef.value?.show('Please enter some content before starting a chat.')
	•	    return
	•	  }
	•	  
	•	  isStartingChat.value = true
	•	  
	•	  try {
	•	    // Save entry first
	•	    const payload = {
	•	      title: title.value.trim() || undefined,
	•	      body: body.value.trim(),
	•	      emotionIds: [...selectedEmotionIds.value],
	•	      peopleTagIds: [...selectedPeopleTagIds.value],
	•	      contextTagIds: [...selectedContextTagIds.value],
	•	    }
	•	    
	•	    let entryId: string
	•	    
	•	    if (isEditMode.value && currentEntry.value) {
	•	      const updated = await journalStore.updateEntry({
	•	        ...currentEntry.value,
	•	        ...payload,
	•	      })
	•	      entryId = updated.id
	•	    } else {
	•	      const created = await journalStore.createEntry(payload)
	•	      entryId = created.id
	•	    }
	•	    
	•	    // Start chat session
	•	    await chatStore.startChatSession(entryId, intention, customPrompt)
	•	    
	•	    // Navigate to chat view
	•	    router.push(`/journal/${entryId}/chat`)
	•	  } catch (error) {
	•	    const errorMessage =
	•	      error instanceof Error
	•	        ? error.message
	•	        : 'Failed to start chat. Please try again.'
	•	    snackbarRef.value?.show(errorMessage)
	•	    console.error('Error starting chat:', error)
	•	  } finally {
	•	    isStartingChat.value = false
	•	  }
	•	}
	•	
	•	function handleCustomPromptConfirm() {
	•	  if (!customPromptInput.value.trim()) {
	•	    snackbarRef.value?.show('Please enter a custom prompt.')
	•	    return
	•	  }
	•	  
	•	  showCustomPromptDialog.value = false
	•	  startChat(CHAT_INTENTIONS.CUSTOM, customPromptInput.value.trim())
	•	  customPromptInput.value = ''
	•	}
	•	```
	•	Click Outside Handler:
	•	Add a click outside handler using Vue's `@click.outside` directive (if using Vue 3.4+) or a manual event listener:
	•	```typescript
	•	import { onClickOutside } from '@vueuse/core' // if using VueUse
	•	// or implement manually
	•	
	•	onMounted(() => {
	•	  // ... existing onMounted code
	•	  
	•	  // Click outside handler for dropdown
	•	  document.addEventListener('click', (e) => {
	•	    if (showChatDropdown.value && !e.target.closest('.chat-dropdown-container')) {
	•	      closeChatDropdown()
	•	    }
	•	  })
	•	})
	•	```
	•	Custom Prompt Dialog:
	•	Add a dialog component for custom prompt input (can use AppDialog if available, or create a simple modal):
	•	```vue
	•	<AppDialog
	•	  v-if="showCustomPromptDialog"
	•	  @close="closeCustomPromptDialog"
	•	  title="Custom Chat Prompt"
	•	>
	•	  <textarea
	•	    v-model="customPromptInput"
	•	    placeholder="E.g., Help me understand why I feel anxious about this situation..."
	•	    class="w-full min-h-[120px] p-3 border rounded-lg"
	•	  />
	•	  <div class="flex gap-3 mt-4">
	•	    <AppButton variant="text" @click="closeCustomPromptDialog">Cancel</AppButton>
	•	    <AppButton
	•	      variant="filled"
	•	      @click="handleCustomPromptConfirm"
	•	      :disabled="!customPromptInput.trim()"
	•	    >
	•	      Start Chat
	•	    </AppButton>
	•	  </div>
	•	</AppDialog>
	•	```
	•	File Organization:
	•	All changes are in `src/views/JournalEditorView.vue`.
	•	Test file: `src/views/__tests__/JournalEditorView.spec.ts` (extend existing test file).
	•	Dependencies:
	•	Import chat store from Story 3.
	•	Import chat intention constants and types from Story 4.
	•	Ensure router is available (already imported).
	•	Testing:
	•	Extend the existing test file `src/views/__tests__/JournalEditorView.spec.ts`.
	•	Add new test suites for Chat button functionality.
	•	Mock chat store and router as needed.
	•	Follow existing test patterns and naming conventions.

