Story 8 – Chat Interface – Save or Discard Conversation

Goal

Implement the save and discard conversation functionality in the ChatView component. This story enables users to persist chat conversations to their journal entries or leave without saving, giving users control over which conversations are stored. The implementation includes save functionality with success feedback, discard functionality with confirmation dialogs, and proper navigation handling.

⸻

Scope

	1.	Save Conversation Button Implementation
	•	Enable the "Save conversation" button (which was added as a placeholder in Story 6):
	•	Button state management:
	•	Enable the button only after at least one message exchange has occurred (both user and AI messages exist).
	•	Use computed property to determine if the button should be enabled:
	•	Check that `chatStore.currentChatSession` exists.
	•	Check that the session has at least 2 messages (one user message and one AI response).
	•	Disable the button while saving is in progress (prevent duplicate saves).
	•	Disable the button if the conversation is already saved (optional: show "Saved" state instead of button).
	•	Button styling:
	•	Use AppButton component with "filled" variant.
	•	Position: In the top app bar (as a secondary action) or in a bottom action bar.
	•	Show loading state while saving (spinner or "Saving..." text).
	•	Button text: "Save conversation" (or "Save" for shorter label).
	•	Save functionality:
	•	When user clicks "Save conversation":
	•	Call `chatStore.saveChatSession(entryId, chatSession)` to persist the conversation.
	•	Handle the async operation (await the promise).
	•	On success:
	•	Show success feedback (e.g., AppSnackbar with message "Conversation saved successfully").
	•	Navigate back to journal editor (`/journal/:id/edit`) or journal list (`/journal`).
	•	On error:
	•	Show error message (e.g., "Failed to save conversation. Please try again.").
	•	Keep the user on the chat view (don't navigate away on error).
	•	Allow user to retry saving.
	•	Prevent duplicate saves:
	•	Track whether the conversation has been saved (use a flag or check if session has an ID that exists in the entry).
	•	Disable save button after successful save (or show "Saved" indicator).
	•	Error handling:
	•	Handle errors from chat store (e.g., entry not found, database errors).
	•	Show user-friendly error messages.
	•	Allow retry on failure.

	2.	Leave Without Saving Button Implementation
	•	Enable the "Leave without saving" or "End chat" button (which was added as a placeholder in Story 6):
	•	Button styling:
	•	Use AppButton component with "text" or "outlined" variant (less prominent than Save button).
	•	Position: In the top app bar (as a secondary action) or near the Save button.
	•	Button text: "Leave without saving" or "End chat" (shorter: "Leave").
	•	Button behavior:
	•	Always enabled (user can leave at any time).
	•	No loading state needed (discard is immediate).
	•	Confirmation dialog:
	•	Show confirmation dialog if there are unsaved messages (at least one message exchange).
	•	Dialog should use AppDialog component (consistent with app design).
	•	Dialog content:
	•	Title: "Leave without saving?"
	•	Message: "You have unsaved messages. Are you sure you want to leave? This conversation will be lost."
	•	Actions:
	•	"Cancel" button: Closes dialog and stays on chat view.
	•	"Leave" button: Confirms discard and navigates away.
	•	If no messages exist (or only system messages), skip confirmation and navigate immediately.
	•	Discard functionality:
	•	When user confirms leaving:
	•	Call `chatStore.discardChatSession()` to clear the unsaved conversation from memory.
	•	Navigate back to journal editor (`/journal/:id/edit`) or journal list (`/journal`).
	•	No data is persisted (conversation is lost).
	•	No success message needed (user is leaving the view).
	•	Handle edge cases:
	•	If user navigates away using browser back button, show confirmation if there are unsaved messages.
	•	Use Vue Router's navigation guard or `beforeRouteLeave` to intercept navigation.
	•	If user refreshes the page, unsaved conversation is lost (this is expected behavior for MVP).

	3.	Chat Store Integration for Save/Discard
	•	Integrate with chat store methods (from Story 3):
	•	Save conversation:
	•	Use `chatStore.saveChatSession(entryId, chatSession)` method.
	•	The method should:
	•	Take the current chat session from `chatStore.currentChatSession`.
	•	Persist it to the journal entry via journal store.
	•	Update the entry's `chatSessions` array to include the new session.
	•	Clear the current chat session from the store (or mark it as saved).
	•	Handle errors and return success/failure status.
	•	Discard conversation:
	•	Use `chatStore.discardChatSession()` method.
	•	The method should:
	•	Clear `chatStore.currentChatSession` (set to null).
	•	Clear any temporary conversation state.
	•	Not persist any data to the database.
	•	Handle edge cases:
	•	If `currentChatSession` is null, discard should be a no-op.
	•	If session is already saved, discard should still clear it from memory.
	•	State management:
	•	Track whether the conversation has been saved (use a flag in the store or check entry's chatSessions).
	•	Provide computed property or getter for "isSaved" state.
	•	Provide computed property for "hasUnsavedMessages" (at least one message exchange).

	4.	Navigation Handling
	•	Implement proper navigation after save/discard:
	•	After successful save:
	•	Navigate to journal editor: `router.push(`/journal/${entryId}/edit`)`.
	•	Or navigate to journal list: `router.push('/journal')`.
	•	Preference: Navigate to editor so user can see the saved chat session.
	•	After discard:
	•	Navigate to journal editor: `router.push(`/journal/${entryId}/edit`)`.
	•	Or navigate to journal list: `router.push('/journal')`.
	•	Preference: Navigate to editor so user can continue editing the entry.
	•	Browser back button handling:
	•	Use Vue Router's `beforeRouteLeave` navigation guard to intercept navigation.
	•	Check if there are unsaved messages.
	•	If unsaved messages exist, show confirmation dialog.
	•	If user confirms, discard conversation and allow navigation.
	•	If user cancels, prevent navigation (stay on chat view).
	•	Handle edge cases:
	•	If entry doesn't exist, navigate to journal list instead.
	•	If user is already on the target route, skip navigation.

	5.	Success Feedback & Error Handling
	•	Implement success feedback for save operation:
	•	Use AppSnackbar component (if available) for transient success messages.
	•	Message: "Conversation saved successfully" or "Chat saved".
	•	Display duration: 3-5 seconds (auto-dismiss).
	•	Position: Bottom of screen (standard snackbar position).
	•	Alternative: Show inline success message near the Save button (if snackbar is not available).
	•	Error feedback:
	•	Use AppSnackbar for error messages (transient).
	•	Or show inline error message near the Save button.
	•	Error messages:
	•	"Failed to save conversation. Please try again." (generic error).
	•	"Entry not found. Cannot save conversation." (entry missing).
	•	"Database error. Please try again." (database failure).
	•	Allow retry: Keep the conversation in memory so user can retry saving.
	•	Error state persistence:
	•	Errors should be visible until user takes action (dismisses, retries, or navigates away).
	•	Clear error state when save succeeds or user navigates away.

	6.	Confirmation Dialog Component
	•	Implement or use confirmation dialog for "Leave without saving":
	•	Use AppDialog component (if available) or create a simple confirmation dialog.
	•	Dialog structure:
	•	Title: "Leave without saving?"
	•	Message: "You have unsaved messages. Are you sure you want to leave? This conversation will be lost."
	•	Actions:
	•	"Cancel" button: Closes dialog, stays on chat view.
	•	"Leave" button: Confirms discard, navigates away.
	•	Dialog styling:
	•	Use consistent styling with app (AppDialog, AppButton components).
	•	Follow Material Design principles.
	•	Dialog state management:
	•	Use reactive ref to control dialog visibility: `const showDiscardDialog = ref(false)`.
	•	Show dialog when user clicks "Leave without saving" and there are unsaved messages.
	•	Hide dialog when user confirms or cancels.
	•	Handle keyboard:
	•	Escape key closes dialog (cancels).
	•	Enter key confirms (leaves).

	7.	State Tracking & Computed Properties
	•	Implement computed properties for button states and conditions:
	•	`canSave`: Computed property that returns true if:
	•	Chat session exists.
	•	Session has at least 2 messages (user + AI).
	•	Session is not already saved.
	•	Not currently saving.
	•	`hasUnsavedMessages`: Computed property that returns true if:
	•	Chat session exists.
	•	Session has at least 2 messages (user + AI).
	•	Session is not saved.
	•	`isSaving`: Computed property that returns true if save operation is in progress.
	•	`isSaved`: Computed property that returns true if the conversation has been saved.
	•	Implementation:
	•	Use Vue's `computed()` function.
	•	Access chat store state: `chatStore.currentChatSession`, `chatStore.isLoading`, etc.
	•	Check journal entry's chatSessions array to determine if current session is saved.
	•	Reactive updates: Ensure computed properties update when store state changes.

	8.	Integration with Journal Store
	•	Ensure chat store's saveChatSession method integrates with journal store:
	•	The saveChatSession method should:
	•	Get the current journal entry from journal store.
	•	Add the chat session to the entry's chatSessions array.
	•	Update the entry using journal store's update method.
	•	Handle the case where entry.chatSessions is undefined (initialize as empty array).
	•	Ensure the chat session has a unique ID (UUID) before saving.
	•	Preserve existing chat sessions (append, don't replace).
	•	Error handling:
	•	If entry doesn't exist, throw error or return failure.
	•	If update fails, throw error or return failure.
	•	The chat store should handle these errors and provide user-friendly messages.

	9.	Component Tests
	•	Add comprehensive component tests (Vitest with Vue Test Utils) for:
	•	Save Conversation Button:
	•	Test that button is disabled when no messages exist.
	•	Test that button is enabled after at least one message exchange.
	•	Test that button is disabled while saving is in progress.
	•	Test that button is disabled after successful save.
	•	Test that clicking Save calls `chatStore.saveChatSession` with correct parameters.
	•	Test that success feedback is shown after successful save.
	•	Test that navigation occurs after successful save.
	•	Test that error message is shown if save fails.
	•	Test that user can retry after error.
	•	Leave Without Saving Button:
	•	Test that button is always enabled.
	•	Test that clicking Leave shows confirmation dialog if there are unsaved messages.
	•	Test that clicking Leave navigates immediately if no messages exist.
	•	Test that confirmation dialog has correct title and message.
	•	Test that Cancel button closes dialog and stays on chat view.
	•	Test that Leave button in dialog calls `chatStore.discardChatSession` and navigates.
	•	Test that Escape key closes dialog.
	•	Navigation Guard:
	•	Test that `beforeRouteLeave` shows confirmation if there are unsaved messages.
	•	Test that confirming in guard allows navigation and discards conversation.
	•	Test that canceling in guard prevents navigation.
	•	Test that navigation is allowed if no unsaved messages.
	•	State Management:
	•	Test that computed properties (`canSave`, `hasUnsavedMessages`, `isSaving`, `isSaved`) work correctly.
	•	Test that properties update reactively when store state changes.
	•	Error Handling:
	•	Test that errors from chat store are displayed correctly.
	•	Test that user can retry after error.
	•	Edge Cases:
	•	Test with empty chat session (no messages).
	•	Test with already saved conversation.
	•	Test with missing journal entry.
	•	Test with network errors during save.
	•	Use mocking for:
	•	Chat store (mock `saveChatSession`, `discardChatSession`, `currentChatSession`).
	•	Journal store (mock `getEntryById`, `updateEntry`).
	•	Router (mock `router.push`, `router.back`).
	•	Follow existing test patterns in `src/views/__tests__/`.
	•	Use descriptive test names that explain what is being tested.

	10.	Integration Tests
	•	Add integration tests for full save and discard flows:
	•	Save Flow Integration Test:
	•	Create a journal entry.
	•	Navigate to chat view.
	•	Start a chat session with an intention.
	•	Send a user message and receive AI response.
	•	Click "Save conversation" button.
	•	Verify that chat session is saved to the entry (check entry.chatSessions).
	•	Verify that success feedback is shown.
	•	Verify that navigation occurs.
	•	Verify that conversation persists after page refresh.
	•	Discard Flow Integration Test:
	•	Create a journal entry.
	•	Navigate to chat view.
	•	Start a chat session with an intention.
	•	Send a user message and receive AI response.
	•	Click "Leave without saving" button.
	•	Confirm in dialog.
	•	Verify that chat session is NOT saved to the entry.
	•	Verify that navigation occurs.
	•	Verify that conversation is lost after page refresh.
	•	Browser Navigation Integration Test:
	•	Create a journal entry.
	•	Navigate to chat view.
	•	Start a chat session and send messages.
	•	Use browser back button.
	•	Verify that confirmation dialog appears.
	•	Confirm discard.
	•	Verify that conversation is not saved.
	•	Error Scenario Integration Test:
	•	Create a journal entry.
	•	Navigate to chat view.
	•	Start a chat session and send messages.
	•	Mock journal store update to fail.
	•	Click "Save conversation".
	•	Verify that error message is shown.
	•	Verify that user can retry.
	•	Use test utilities from `src/__tests__/integration/testUtils.ts` if available.
	•	Follow existing integration test patterns.

⸻

Acceptance Criteria

	•	Save Conversation Button:
	•	Button is present and properly styled (uses AppButton component).
	•	Button is disabled when no messages exist or only one message exists.
	•	Button is enabled after at least one message exchange (user + AI messages).
	•	Button is disabled while saving is in progress (shows loading state).
	•	Button is disabled after successful save (or shows "Saved" state).
	•	Clicking Save calls `chatStore.saveChatSession` with correct parameters.
	•	Success feedback is shown after successful save (AppSnackbar or inline message).
	•	Navigation occurs after successful save (to journal editor or journal list).
	•	Error message is shown if save fails.
	•	User can retry saving after error.
	•	Leave Without Saving Button:
	•	Button is present and properly styled (uses AppButton component).
	•	Button is always enabled.
	•	Clicking Leave shows confirmation dialog if there are unsaved messages.
	•	Clicking Leave navigates immediately if no messages exist.
	•	Confirmation dialog has correct title and message.
	•	Cancel button in dialog closes dialog and stays on chat view.
	•	Leave button in dialog calls `chatStore.discardChatSession` and navigates.
	•	Escape key closes dialog.
	•	Navigation Guard:
	•	`beforeRouteLeave` shows confirmation if there are unsaved messages.
	•	Confirming in guard allows navigation and discards conversation.
	•	Canceling in guard prevents navigation.
	•	Navigation is allowed if no unsaved messages.
	•	State Management:
	•	Computed properties (`canSave`, `hasUnsavedMessages`, `isSaving`, `isSaved`) work correctly.
	•	Properties update reactively when store state changes.
	•	Chat Store Integration:
	•	`saveChatSession` method persists conversation to journal entry.
	•	`discardChatSession` method clears conversation from memory.
	•	Methods handle errors gracefully.
	•	Journal Store Integration:
	•	Chat sessions are correctly added to entry's chatSessions array.
	•	Existing chat sessions are preserved (not replaced).
	•	Entry update succeeds and persists to database.
	•	The app can be started and:
	•	Users can save conversations after having a chat.
	•	Users can leave without saving (with confirmation if needed).
	•	Saved conversations persist after page refresh.
	•	Discarded conversations are not saved.
	•	Navigation works correctly after save/discard.
	•	Component tests for save/discard functionality pass.
	•	Integration tests for save/discard flows pass.
	•	Linting and TypeScript checks pass with no new errors.

⸻

Out of Scope

	•	Editing saved conversations (out of scope for this epic).
	•	Deleting saved conversations (will be implemented in Story 9).
	•	Viewing chat history in detail (will be implemented in Story 9).
	•	Exporting conversations (out of scope for this epic).
	•	Multiple save operations on the same conversation (once saved, it's saved).
	•	Undo save operation (cannot unsave a saved conversation).
	•	Auto-save functionality (conversations are only saved when user explicitly clicks Save).
	•	Chat session versioning or history (each save creates a new session).
	•	Advanced error recovery (basic retry is sufficient for MVP).

⸻

Technical Considerations

	•	Save Button State Management:
	•	Determine if conversation is saved by checking if the current session's ID exists in the entry's chatSessions array.
	•	Or use a flag in the chat store to track save state.
	•	Consider edge case: What if user saves, then continues chatting? Should it create a new session or update the existing one?
	•	For MVP, recommend: Once saved, the session is immutable. New messages create a new session.
	•	Confirmation Dialog UX:
	•	Make the confirmation dialog clear and non-intrusive.
	•	Use destructive action styling for "Leave" button (e.g., error color or outlined variant).
	•	Ensure dialog is accessible (keyboard navigation, screen reader support).
	•	Navigation Guard Implementation:
	•	Use Vue Router's `beforeRouteLeave` navigation guard.
	•	The guard receives `to`, `from`, and `next` parameters.
	•	Call `next(false)` to prevent navigation, or `next()` to allow it.
	•	Show confirmation dialog asynchronously (use a promise or callback).
	•	Handle edge cases: What if user closes the browser tab? (Cannot intercept, conversation is lost - this is acceptable for MVP).
	•	Error Recovery:
	•	If save fails, keep the conversation in memory so user can retry.
	•	Don't clear the chat session on error.
	•	Show clear error messages with actionable guidance.
	•	Consider adding a "Retry" button for failed saves (optional enhancement).
	•	Performance:
	•	Save operation should be fast (just adding to array and updating entry).
	•	If entry is large, consider optimizing the update operation.
	•	For MVP, performance should be fine with typical entry sizes.
	•	Data Integrity:
	•	Ensure chat session has valid ID (UUID) before saving.
	•	Ensure chat session has required fields (journalEntryId, intention, messages, createdAt).
	•	Validate that entry exists before saving.
	•	Handle race conditions: What if entry is deleted while user is chatting? (Show error and allow navigation).
	•	Testing Strategy:
	•	Mock chat store and journal store thoroughly in component tests.
	•	Test both success and error scenarios.
	•	Test edge cases (empty messages, already saved, missing entry).
	•	Use integration tests to verify full flow with real stores (or mocked stores that behave like real ones).
	•	Accessibility:
	•	Ensure buttons have proper ARIA labels.
	•	Ensure confirmation dialog is accessible (keyboard navigation, screen reader announcements).
	•	Manage focus appropriately (focus should return to appropriate element after dialog closes).

⸻

Implementation Notes

	•	Save Button Implementation:
	•	```vue
	•	<AppButton
	•	  variant="filled"
	•	  @click="handleSave"
	•	  :disabled="!canSave || isSaving"
	•	  aria-label="Save conversation"
	•	>
	•	  <span v-if="isSaving">Saving...</span>
	•	  <span v-else-if="isSaved">Saved</span>
	•	  <span v-else>Save conversation</span>
	•	</AppButton>
	•	```
	•	Computed Properties:
	•	```typescript
	•	const canSave = computed(() => {
	•	  const session = chatStore.currentChatSession
	•	  if (!session) return false
	•	  if (isSaving.value) return false
	•	  if (isSaved.value) return false
	•	  // At least one user message and one AI response
	•	  const userMessages = session.messages.filter(m => m.role === 'user')
	•	  const aiMessages = session.messages.filter(m => m.role === 'assistant')
	•	  return userMessages.length > 0 && aiMessages.length > 0
	•	})
	•	
	•	const hasUnsavedMessages = computed(() => {
	•	  return canSave.value && !isSaved.value
	•	})
	•	
	•	const isSaving = computed(() => {
	•	  return chatStore.isSaving || false
	•	})
	•	
	•	const isSaved = computed(() => {
	•	  const session = chatStore.currentChatSession
	•	  if (!session) return false
	•	  const entry = journalStore.getEntryById(entryId.value)
	•	  if (!entry?.chatSessions) return false
	•	  return entry.chatSessions.some(cs => cs.id === session.id)
	•	})
	•	```
	•	Save Handler:
	•	```typescript
	•	async function handleSave() {
	•	  if (!canSave.value) return
	•	  
	•	  try {
	•	    await chatStore.saveChatSession(entryId.value, chatStore.currentChatSession!)
	•	    snackbar.show('Conversation saved successfully', 'success')
	•	     await router.push(`/journal/${entryId.value}/edit`)
	•	  } catch (error) {
	•	    snackbar.show('Failed to save conversation. Please try again.', 'error')
	•	    console.error('Error saving conversation:', error)
	•	  }
	•	}
	•	```
	•	Leave Without Saving Handler:
	•	```typescript
	•	const showDiscardDialog = ref(false)
	•	
	•	function handleLeave() {
	•	  if (hasUnsavedMessages.value) {
	•	    showDiscardDialog.value = true
	•	  } else {
	•	    handleDiscard()
	•	  }
	•	}
	•	
	•	async function handleDiscard() {
	•	  chatStore.discardChatSession()
	•	  showDiscardDialog.value = false
	•	  await router.push(`/journal/${entryId.value}/edit`)
	•	}
	•	```
	•	Navigation Guard:
	•	```typescript
	•	import { onBeforeRouteLeave } from 'vue-router'
	•	
	•	onBeforeRouteLeave((to, from, next) => {
	•	  if (hasUnsavedMessages.value) {
	•	     const confirmed = confirm('You have unsaved messages. Are you sure you want to leave? This conversation will be lost.')
	•	     if (confirmed) {
	•	       chatStore.discardChatSession()
	•	       next()
	•	     } else {
	•	       next(false)
	•	     }
	•	   } else {
	•	     next()
	•	   }
	•	})
	•	```
	•	Note: For better UX, use AppDialog instead of browser confirm().
	•	Confirmation Dialog:
	•	```vue
	•	<AppDialog
	•	  v-model="showDiscardDialog"
	•	  title="Leave without saving?"
	•	  :actions="[
	•	    { label: 'Cancel', variant: 'text', onClick: () => showDiscardDialog = false },
	•	    { label: 'Leave', variant: 'filled', onClick: handleDiscard, destructive: true }
	•	  ]"
	•	>
	•	  <p>You have unsaved messages. Are you sure you want to leave? This conversation will be lost.</p>
	•	</AppDialog>
	•	```
	•	Chat Store saveChatSession Method (if not already implemented in Story 3):
	•	```typescript
	•	async saveChatSession(entryId: string, chatSession: ChatSession): Promise<void> {
	•	  this.isSaving = true
	•	  this.error = null
	•	  
	•	  try {
	•	    const entry = await journalStore.getEntryById(entryId)
	•	    if (!entry) {
	•	      throw new Error('Journal entry not found')
	•	    }
	•	    
	•	    // Ensure chat session has an ID
	•	    if (!chatSession.id) {
	•	      chatSession.id = generateUUID()
	•	    }
	•	    
	•	    // Initialize chatSessions array if needed
	•	    const chatSessions = entry.chatSessions || []
	•	    
	•	    // Check if session already exists (avoid duplicates)
	•	    if (!chatSessions.some(cs => cs.id === chatSession.id)) {
	•	      chatSessions.push(chatSession)
	•	    }
	•	    
	•	    // Update entry
	•	    await journalStore.updateEntry({
	•	      ...entry,
	•	      chatSessions
	•	    })
	•	    
	•	    // Clear current session (or mark as saved)
	•	    this.currentChatSession = null
	•	  } catch (error) {
	•	    this.error = error instanceof Error ? error.message : 'Failed to save conversation'
	•	    throw error
	•	  } finally {
	•	    this.isSaving = false
	•	  }
	•	}
	•	```
	•	Chat Store discardChatSession Method (if not already implemented in Story 3):
	•	```typescript
	•	discardChatSession(): void {
	•	  this.currentChatSession = null
	•	  this.error = null
	•	}
	•	```
	•	File Organization:
	•	All changes are in `src/views/ChatView.vue` (extending Story 6 and Story 7).
	•	Chat store methods may need to be added or updated in `src/stores/chat.store.ts` (if not already implemented in Story 3).
	•	Test file: `src/views/__tests__/ChatView.spec.ts` (extend existing test file from Story 6 and Story 7).
	•	Integration test file: `src/__tests__/integration/chat-save-discard-flow.spec.ts` (new file).
	•	Dependencies:
	•	Import chat store from Story 3.
	•	Import journal store (assume it exists).
	•	Import router and route from vue-router.
	•	Import UI components (AppButton, AppDialog, AppSnackbar if available).
	•	Testing:
	•	Extend the existing test file from Story 6 and Story 7.
	•	Add new test suites for save and discard functionality.
	•	Mock chat store and journal store thoroughly.
	•	Test user interactions (clicking buttons, confirming dialogs).
	•	Test navigation guards.
	•	Test reactive updates and state management.
	•	Follow existing test patterns and naming conventions.
	•	Create integration tests for full save/discard flows.

