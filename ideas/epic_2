Epic 2 – Emotion System, Tagging & Emotion Logging

1. Goal

Establish the shared emotion system foundation and implement tagging capabilities across the app. By the end of this epic, users can tag journal entries and create emotion logs with emotions, people, and context tags. The emotion system uses a 2×2 quadrant grid (pleasantness × energy) with a comprehensive set of emotions, and all tagging features are implemented as reusable components that will be used across Journal, Emotions, and (later) Exercises views.

⸻

2. Scope

This epic covers:

	1.	Emotions Database & Domain Model
	•	Define the Emotion domain model:

interface Emotion {
  id: string;           // UUID
  name: string;         // e.g., "Happy", "Anxious", "Serene"
  pleasantness: number; // 1-10 scale (1 = very low, 10 = very high)
  energy: number;       // 1-10 scale (1 = very low, 10 = very high)
  description?: string; // Optional description of the emotion
}


	•	Create a static seed data file containing approximately 100 emotions organized by quadrant:
	•	High Energy / High Pleasantness (e.g., Ecstatic, Thrilled, Joyful, Excited, Enthusiastic, etc.)
	•	High Energy / Low Pleasantness (e.g., Angry, Anxious, Stressed, Frustrated, Panicked, etc.)
	•	Low Energy / High Pleasantness (e.g., Serene, Calm, Content, Peaceful, Relaxed, etc.)
	•	Low Energy / Low Pleasantness (e.g., Sad, Depressed, Exhausted, Lonely, Hopeless, etc.)
	•	Each emotion should have appropriate pleasantness and energy values (1-10 scale) based on its position in the 2×2 grid.
	•	The seed data should be easily modifiable by developers (stored in a JSON file).
	•	Implement a Pinia store useEmotionStore that:
	•	Holds all emotions: Emotion[].
	•	Loads emotions from seed data on initialization.
	•	Provides getters:
	•	getAllEmotions(): Emotion[]
	•	getEmotionsByQuadrant(quadrant: Quadrant): Emotion[]
	•	getEmotionById(id: string): Emotion | undefined
	•	Quadrant type definition:

type Quadrant = 
  | 'high-energy-high-pleasantness'
  | 'high-energy-low-pleasantness'
  | 'low-energy-high-pleasantness'
  | 'low-energy-low-pleasantness'


	•	Quadrant determination logic: emotions are categorized into quadrants based on their pleasantness and energy values (e.g., energy > 5 and pleasantness > 5 = high-energy-high-pleasantness).

	2.	People & Context Tag Domain Models
	•	Define domain models for user-created tags:

interface PeopleTag {
  id: string;  // UUID
  name: string; // User-defined name (e.g., "Mom", "John", "Work Team")
}


interface ContextTag {
  id: string;  // UUID
  name: string; // User-defined name (e.g., "Morning Routine", "Work Meeting", "Exercise")
}


	•	Define repository interfaces:

interface PeopleTagRepository {
  getAll(): Promise<PeopleTag[]>;
  getById(id: string): Promise<PeopleTag | undefined>;
  create(data: { name: string }): Promise<PeopleTag>;
  delete(id: string): Promise<void>;
}


interface ContextTagRepository {
  getAll(): Promise<ContextTag[]>;
  getById(id: string): Promise<ContextTag | undefined>;
  create(data: { name: string }): Promise<ContextTag>;
  delete(id: string): Promise<void>;
}


	•	Implement concrete repositories using IndexedDB via Dexie.
	•	Extend the existing MindfullGrowthDatabase class (from journalDexieRepository.ts) to add peopleTags and contextTags tables.
	•	Increment database version from 1 to 2 to add the new tables.
	•	Note: The database instance is a singleton, so the tag repositories should extend the existing database class. If this becomes unwieldy, the database class can be refactored to a shared module in a future story.
	•	Implement a Pinia store useTagStore that:
	•	Manages both people and context tags:
	•	peopleTags: PeopleTag[]
	•	contextTags: ContextTag[]
	•	Provides actions:
	•	loadPeopleTags()
	•	loadContextTags()
	•	createPeopleTag(name: string): Promise<PeopleTag>
	•	createContextTag(name: string): Promise<ContextTag>
	•	deletePeopleTag(id: string): Promise<void>
	•	deleteContextTag(id: string): Promise<void>
	•	Provides getters:
	•	getPeopleTagById(id: string): PeopleTag | undefined
	•	getContextTagById(id: string): ContextTag | undefined
	•	Handles duplicate tag creation: if a tag with the same name (case-insensitive) already exists, return the existing tag instead of creating a duplicate.
	•	Tags are loaded on app start or when the store is first accessed.

	3.	Emotion Selector Component (Shared)
	•	Create a reusable EmotionSelector component that:
	•	Displays a quadrant selector as the first step:
	•	Four large, visually distinct buttons/cards representing the four quadrants:
	•	High Energy / High Pleasantness (e.g., yellow/warm colors)
	•	High Energy / Low Pleasantness (e.g., red/orange colors)
	•	Low Energy / High Pleasantness (e.g., green/calm colors)
	•	Low Energy / Low Pleasantness (e.g., blue/cool colors)
	•	Each quadrant button shows a label and visual indicator (color and icon).
	•	After selecting a quadrant:
	•	Displays emotions from that quadrant as selectable chips/badges.
	•	Emotions are displayed in a grid or list layout, each as a Material-style chip.
	•	Users can select multiple emotions from the current quadrant.
	•	Selected emotions are visually distinct (e.g., filled vs. outlined chips).
	•	Navigation between quadrants:
	•	Users can switch between quadrants at any time (e.g., via quadrant buttons that remain visible and a back button to return to quadrant selection).
	•	Selected emotions persist when switching quadrants (users can select from multiple quadrants in one session).
	•	Selected emotions display:
	•	Shows all currently selected emotions as chips (regardless of which quadrant they came from).
	•	Each selected emotion chip can be removed (e.g., with a click to deselect).
	•	Component API:
	•	Accepts v-model for selected emotion IDs: string[].
	•	Emits update:modelValue when selection changes.
	•	Optionally accepts initial selection via props.
	•	Follows Material Design principles for chips and navigation.
	•	Component should be accessible and keyboard-navigable.

	4.	Tag Input Components (Shared)
	•	Create a reusable TagInput component for people tags:
	•	Displays existing people tags as chips (from useTagStore).
	•	Provides a text input field for creating new tags.
	•	On typing and pressing Enter (or clicking an "Add" button):
	•	Creates a new tag if it doesn't exist (case-insensitive duplicate check).
	•	If a tag with the same name exists, selects the existing tag instead.
	•	Shows selected tags as chips with remove functionality.
	•	Provides autocomplete/suggestions from existing tags as the user types.
	•	Component API:
	•	Accepts v-model for selected tag IDs: string[].
	•	Emits update:modelValue when selection changes.
	•	Optionally accepts initial selection via props.
	•	Create a reusable TagInput component for context tags (or make it generic to handle both):
	•	Same behavior as people tag input, but manages context tags.
	•	If implemented as a generic component, accepts a prop to specify tag type (people vs. context).

	5.	JournalEntry Data Model Updates
	•	Update the JournalEntry interface to include tagging fields:

interface JournalEntry {
  id: string;
  createdAt: string;
  updatedAt: string;
  title?: string;
  body: string;
  emotionIds: string[];        // Array of Emotion IDs
  peopleTagIds: string[];      // Array of PeopleTag IDs
  contextTagIds: string[];      // Array of ContextTag IDs
}


	•	Update the JournalRepository interface to handle the new fields (no changes needed to method signatures, but implementations must persist all fields).
	•	Note: The Dexie database schema for tag tables (peopleTags, contextTags) is already created in Story 2 (version 2). The journal entry migration will be handled in Story 5.
	•	Update useJournalStore:
	•	Ensure createEntry and updateEntry handle the new tagging fields.
	•	No changes needed to method signatures, but payload types should include optional emotionIds, peopleTagIds, contextTagIds.
	•	Migration strategy (handled in Story 5):
	•	Increment Dexie database version from 2 to 3.
	•	Create a migration that:
	•	Adds default empty arrays ([]) for emotionIds, peopleTagIds, contextTagIds to all existing JournalEntry records.
	•	Ensures backward compatibility: existing entries without these fields are treated as having empty arrays.

	6.	Journal Editor Integration
	•	Update JournalEditorView to include tagging sections:
	•	Add an "Emotions" section:
	•	Displays the EmotionSelector component.
	•	Shows selected emotions as chips below the selector.
	•	Add a "People" section:
	•	Displays the TagInput component for people tags.
	•	Add a "Context" section:
	•	Displays the TagInput component for context tags.
	•	Layout:
	•	Tagging sections appear below the title and body fields, before the action buttons.
	•	Sections are clearly labeled and visually separated.
	•	All tagging is optional (no validation required).
	•	Save behavior:
	•	On save (create or edit mode), includes selected emotionIds, peopleTagIds, and contextTagIds in the payload.
	•	Load behavior:
	•	In edit mode, pre-populates all tag selectors with existing tag IDs from the entry.

	7.	Journal View Display Updates
	•	Update JournalView entry cards to display tags:
	•	Each entry card shows:
	•	Selected emotions as chips (display emotion names, not IDs).
	•	Selected people tags as chips (display tag names).
	•	Selected context tags as chips (display tag names).
	•	Tags are displayed below the entry preview text.
	•	No truncation: all tags are shown (may wrap to multiple lines if needed).
	•	Visual distinction: different chip styles or colors for emotions vs. people vs. context tags.

	8.	EmotionLog Domain Model & Persistence
	•	Define the EmotionLog domain model:

interface EmotionLog {
  id: string;              // UUID
  createdAt: string;       // ISO timestamp
  updatedAt: string;       // ISO timestamp
  emotionIds: string[];    // Array of Emotion IDs (required, at least one)
  note?: string;           // Optional short note
  peopleTagIds?: string[]; // Array of PeopleTag IDs (optional)
  contextTagIds?: string[]; // Array of ContextTag IDs (optional)
}


	•	Define repository interface:

interface EmotionLogRepository {
  getAll(): Promise<EmotionLog[]>;
  getById(id: string): Promise<EmotionLog | undefined>;
  create(
    data: Omit<EmotionLog, "id" | "createdAt" | "updatedAt">
  ): Promise<EmotionLog>;
  update(log: EmotionLog): Promise<EmotionLog>;
  delete(id: string): Promise<void>;
}


	•	Implement concrete repository using IndexedDB via Dexie.
	•	Extend the existing MindfullGrowthDatabase class to add emotionLogs table.
	•	Note: The emotionLogs table will be added in Story 5's database migration (version 2 → 3), along with the journal entry field migration.
	•	Implement a Pinia store useEmotionLogStore that:
	•	Holds logs: EmotionLog[].
	•	Provides actions:
	•	loadLogs()
	•	createLog(payload)
	•	updateLog(log)
	•	deleteLog(id)
	•	Delegates persistence to the repository implementation.
	•	Ensures logs are loaded on app start or when the Emotions view is mounted.
	•	Validation: createLog and updateLog must validate that emotionIds contains at least one emotion.

	9.	Emotions View Implementation
	Route: /emotions → EmotionsView
	UI/behavior:
	•	Primary action button: "Log emotion" (large, prominent button or card).
	•	Clicking "Log emotion":
	•	Navigates to /emotions/edit (an emotion log editor).
	•	Below the primary action:
	•	If there are no emotion logs:
	•	Simple "No emotion logs" message
	•	If emotion logs exist:
	•	Display a vertical list of emotion logs (most recent first).
	•	Each log shown as a list item/card with:
	•	Selected emotions displayed as chips (emotion names).
	•	Note preview (if note exists): first 100 characters with ellipsis if truncated.
	•	Creation date/time.
	•	People and context tags as chips (if any).
	•	Clicking a log card:
	•	Navigates to /emotions/:id/edit (edit mode) to edit the selected log.
	•	Each log card has a delete button (trash icon) in the top-right corner:
	•	Clicking delete shows a confirmation dialog (AppDialog).
	•	Confirming deletion removes the log from the list.

	10.	Emotion Log Editor
	Routes: /emotions/edit (create mode) and /emotions/:id/edit (edit mode) → EmotionLogEditorView
	UI/behavior:
	•	Top app bar:
	•	Back navigation (to /emotions).
	•	Title such as "Log emotion" or "Edit log" (depending on mode).
	•	Content:
	•	Emotions section (required):
	•	EmotionSelector component.
	•	Validation: at least one emotion must be selected before saving.
	•	Note field (optional):
	•	Multiline text area for a short note.
	•	People tags section (optional):
	•	TagInput component for people tags.
	•	Context tags section (optional):
	•	TagInput component for context tags.
	•	Small text showing the current date/time (create mode) or log's creation date (edit mode).
	•	Actions:
	•	Save (primary filled button).
	•	Cancel (outlined button, or using back navigation).
	Logic:
	•	On mount in "create mode" (/emotions/edit):
	•	Initialize local state with empty emotionIds, note, peopleTagIds, contextTagIds.
	•	On mount in "edit mode" (/emotions/:id/edit):
	•	Load the log data using the log ID from route params.
	•	Pre-populate all fields with log data.
	•	Show log's createdAt date in timestamp display.
	•	On Save (create mode):
	•	Validate that at least one emotion is selected (emotionIds.length > 0).
	•	Call emotionLogStore.createLog({ emotionIds, note, peopleTagIds, contextTagIds }).
	•	The store is responsible for:
	•	Generating id.
	•	Setting createdAt and updatedAt.
	•	Persisting via the repository.
	•	Navigate back to /emotions.
	•	On Save (edit mode):
	•	Validate that at least one emotion is selected.
	•	Call emotionLogStore.updateLog(log) with updated data.
	•	The store is responsible for:
	•	Updating updatedAt timestamp.
	•	Persisting changes via the repository.
	•	Navigate back to /emotions.
	•	On Cancel:
	•	Navigate back to /emotions without saving changes.
	•	Error handling:
	•	Show validation error if user tries to save without selecting at least one emotion.

	11.	Database Migration Strategy
	•	Note: Database version management:
	•	Story 2 increments version from 1 to 2 to add peopleTags and contextTags tables.
	•	Story 5 (this story) increments version from 2 to 3 to add emotionLogs table and migrate journal entries.
	•	Update MindfullGrowthDatabase schema to include:
	•	emotionLogs table (id as primary key).
	•	Note: peopleTags and contextTags tables are already created in Story 2 (version 2).
	•	Migration logic:
	•	Add migration function that:
	•	Adds emotionIds, peopleTagIds, contextTagIds fields to existing journalEntries (defaulting to empty arrays).
	•	Creates new table for emotionLogs.
	•	Ensures data integrity: no data loss for existing journal entries.
	•	Migration should run automatically when the app detects the database version change.

	12.	Tooling & Testing
	•	Add comprehensive automated tests:
	•	Unit tests (Vitest) for:
	•	useEmotionStore:
	•	Loads emotions from seed data correctly.
	•	getEmotionsByQuadrant returns correct emotions for each quadrant.
	•	getEmotionById retrieves correct emotion.
	•	useTagStore:
	•	Creating a people tag adds it to the store and persists to IndexedDB.
	•	Creating a context tag adds it to the store and persists to IndexedDB.
	•	Creating a duplicate tag (case-insensitive) returns existing tag instead of creating a new one.
	•	Deleting a tag removes it from the store and IndexedDB.
	•	Tags persist between sessions.
	•	useEmotionLogStore:
	•	Creating a log sets timestamps and appends to state.
	•	Creating a log without emotions throws validation error.
	•	Updating a log updates the log and updatedAt timestamp.
	•	Deleting a log removes it from the store.
	•	useJournalStore (updated):
	•	Creating/updating entries with tags persists tag IDs correctly.
	•	Loading entries with tags loads all tag IDs.
	•	EmotionSelector component:
	•	Renders quadrant selector.
	•	Selecting a quadrant shows emotions from that quadrant.
	•	Users can select multiple emotions.
	•	Users can switch quadrants and selections persist.
	•	Selected emotions can be removed.
	•	v-model binding works correctly.
	•	TagInput component:
	•	Displays existing tags as chips.
	•	Creating a new tag adds it to the store.
	•	Creating a duplicate tag selects existing tag.
	•	Selected tags can be removed.
	•	v-model binding works correctly.
	•	EmotionLogEditorView:
	•	Renders all required fields (emotions, note, tags).
	•	Invokes store's createLog on save (create mode) with correct payload.
	•	Invokes store's updateLog on save (edit mode).
	•	Loads and pre-populates log data in edit mode.
	•	Shows validation error if saving without emotions.
	•	EmotionsView:
	•	Renders "Log emotion" button.
	•	Renders emotion logs list when logs exist.
	•	Log card click navigates to edit route.
	•	Delete button shows confirmation dialog.
	•	JournalEditorView (updated):
	•	Renders EmotionSelector, people TagInput, and context TagInput.
	•	Includes tag IDs in createEntry/updateEntry payloads.
	•	Pre-populates tags in edit mode.
	•	JournalView (updated):
	•	Displays emotions, people, and context tags on entry cards.
	•	Database migration:
	•	Migration adds new fields to existing journal entries correctly.
	•	Migration creates new tables without errors.
	•	No data loss occurs during migration.

⸻

3. Out of Scope (for this Epic)

	•	Guided and periodic journaling flows.
	•	Exercises view implementation beyond simple placeholder.
	•	Profile view implementation beyond simple placeholder (browsing and filtering will come later).
	•	Questionnaires and AI-powered profile/insight features.
	•	Multi-device sync or cloud backup.
	•	Rich text formatting, attachments, or advanced editor features.
	•	Bulk operations (bulk delete, bulk edit).
	•	Swipe-to-delete gestures.
	•	Undo delete functionality.
	•	Tag management UI (viewing all tags, editing tag names, merging duplicates) – this will come in a later epic.
	•	User-created custom emotions (emotion database is static seed data for now).
	•	Filtering by tags/emotions in Journal or Emotions views (this will be in Profile view later).
	•	Emotion statistics or analytics.
	•	Accessibility testing (deferred to later).
	•	Performance testing for large datasets (deferred to later).

⸻

4. Success Criteria

The epic is considered complete when:

	1.	Emotions database:
	•	Contains approximately 100 emotions organized by quadrant.
	•	Emotions are loaded from seed data and accessible via useEmotionStore.
	•	Quadrant categorization works correctly for all emotions.

	2.	Emotion Selector component:
	•	Displays quadrant selector with four distinct quadrants.
	•	Users can select emotions from any quadrant.
	•	Users can switch between quadrants while maintaining selections.
	•	Selected emotions are displayed and can be removed.
	•	Component is reusable and works with v-model.

	3.	Tag Input components:
	•	Users can create people and context tags via free text input.
	•	Duplicate tags (case-insensitive) are handled gracefully (existing tag is reused).
	•	Selected tags are displayed as chips and can be removed.
	•	Tags persist to IndexedDB and are available across sessions.
	•	Components are reusable and work with v-model.

	4.	Journal entries:
	•	Can be tagged with emotions, people, and context tags.
	•	Tags are displayed on entry cards in JournalView.
	•	Tags are saved and loaded correctly (persist to IndexedDB).
	•	Existing journal entries (from Epic 1) are migrated successfully (empty tag arrays added).

	5.	Emotion logs:
	•	Users can create emotion logs with at least one emotion (required).
	•	Users can add optional note, people tags, and context tags.
	•	Emotion logs are displayed in a list in EmotionsView.
	•	Users can edit and delete emotion logs.
	•	All emotion log operations persist to IndexedDB.

	6.	Emotions view:
	•	Shows "Log emotion" button as primary action.
	•	Displays list of emotion logs (most recent first) when logs exist.
	•	Log cards show emotions, note preview, tags, and timestamp.
	•	Users can click a log to edit it.
	•	Users can delete logs with confirmation.

	7.	Database migration:
	•	Existing journal entries are migrated without data loss.
	•	New tables (emotionLogs, peopleTags, contextTags) are created successfully.
	•	Migration runs automatically on app start when version changes.

	8.	All tests pass:
	•	Unit tests for all stores (emotion, tag, emotionLog, updated journal store).
	•	Unit tests for all new components (EmotionSelector, TagInput).
	•	Unit tests for updated views (EmotionLogEditorView, EmotionsView, updated JournalEditorView, updated JournalView).
	•	Unit tests for database migration.
	•	No failing tests, lint errors, or TypeScript errors.

⸻

5. Suggested Story Structure

This epic should be broken down into the following stories, organized by layer and feature area:

Foundation Layer:
	1.	Emotions Database & Domain Model
	•	Define Emotion interface.
	•	Create static seed data file (JSON) with ~100 emotions organized by quadrant.
	•	Define Quadrant type.
	•	Implement useEmotionStore with getters for all emotions, by quadrant, and by ID.
	•	Minimal tests: store loads emotions correctly, quadrant getters work.

	2.	People & Context Tag Domain Models
	•	Define PeopleTag and ContextTag interfaces.
	•	Define repository interfaces (PeopleTagRepository, ContextTagRepository).
	•	Implement IndexedDB repositories using Dexie.
	•	Extend existing MindfullGrowthDatabase class to add peopleTags and contextTags tables.
	•	Increment database version from 1 to 2.
	•	Implement useTagStore with actions for create/delete and getters.
	•	Handle duplicate tag creation (case-insensitive).
	•	Minimal tests: store creates/loads tags, duplicate handling works.

Component Layer:
	3.	Emotion Selector Component
	•	Create reusable EmotionSelector component.
	•	Quadrant selector UI (four distinct quadrants with colors/icons).
	•	Emotion chips display and selection (multi-select, cross-quadrant).
	•	Selected emotions display and removal.
	•	v-model support.
	•	Minimal tests: component renders, selection works, v-model binding.

	4.	Tag Input Components
	•	Create reusable TagInput component (generic for people/context).
	•	Display existing tags as chips.
	•	Free text input for creating new tags.
	•	Autocomplete/suggestions from existing tags.
	•	Duplicate handling (selects existing tag).
	•	v-model support.
	•	Minimal tests: component creates/selects tags, duplicate handling, v-model binding.

Migration:
	5.	Database Migration Strategy
	•	Note: Database version 2 is already created in Story 2 (for peopleTags and contextTags tables).
	•	Increment Dexie database version (2 → 3).
	•	Update schema to add new table: emotionLogs.
	•	Migration function: add emotionIds, peopleTagIds, contextTagIds fields to existing journalEntries (default to empty arrays).
	•	Ensure no data loss.
	•	Minimal tests: migration runs successfully, existing data preserved.

Journal Integration:
	6.	JournalEntry Data Model Updates
	•	Update JournalEntry interface to include emotionIds, peopleTagIds, contextTagIds.
	•	Update JournalRepository interface (no method signature changes, but implementations must persist new fields).
	•	Note: Dexie schema migration for journal entries (adding new fields) is handled in Story 5. The tag tables (peopleTags, contextTags) are already created in Story 2.
	•	Update useJournalStore to handle new tagging fields in createEntry/updateEntry.
	•	Minimal tests: store persists and loads tag IDs correctly.

	7.	Journal Editor Integration
	•	Update JournalEditorView to include EmotionSelector, people TagInput, and context TagInput sections.
	•	Layout: tagging sections below title/body, before action buttons.
	•	Save behavior: include tag IDs in payload.
	•	Load behavior: pre-populate tags in edit mode.
	•	Minimal tests: editor saves/loads tags, components render correctly.

	8.	Journal View Display Updates
	•	Update JournalView entry cards to display emotions, people, and context tags as chips.
	•	Tags displayed below preview text.
	•	Visual distinction between tag types.
	•	No truncation (all tags shown).
	•	Minimal tests: tags display correctly on entry cards.

EmotionLog Feature:
	9.	EmotionLog Domain Model & Persistence
	•	Define EmotionLog interface.
	•	Define EmotionLogRepository interface.
	•	Implement IndexedDB repository using Dexie.
	•	Note: The emotionLogs table will be created in Story 5's database migration (version 2 → 3). The repository implementation can be prepared in this story, but the table creation happens in Story 5.
	•	Implement useEmotionLogStore with CRUD actions.
	•	Validation: emotionIds must contain at least one emotion.
	•	Minimal tests: store creates/updates/deletes logs, validation works.

	10.	Emotions View Implementation
	•	Update EmotionsView with "Log emotion" primary action button.
	•	Display list of emotion logs (most recent first).
	•	Log cards show emotions, note preview, tags, timestamp.
	•	Click to edit, delete with confirmation.
	•	Empty state: "No emotion logs" message.
	•	Minimal tests: view renders logs, navigation works, delete confirmation.

	11.	Emotion Log Editor
	•	Create EmotionLogEditorView component.
	•	Routes: /emotions/edit (create) and /emotions/:id/edit (edit).
	•	EmotionSelector (required, with validation).
	•	Note field (optional textarea).
	•	People and context TagInput components (optional).
	•	Save/Cancel actions.
	•	Validation: at least one emotion required.
	•	Minimal tests: editor creates/updates logs, validation works, pre-populates in edit mode.

Testing:
	12.	Comprehensive Testing
	•	Integration tests for complete flows (create journal entry with tags, create emotion log).
	•	Edge case testing (empty states, error handling, duplicate tags).
	•	Component interaction tests (EmotionSelector + TagInput in editors).
	•	Database migration edge cases.
	•	Cross-view consistency (tags appear correctly in both Journal and Emotions views).

Notes:
	•	Stories 3 and 4 (components) can be developed in parallel once Stories 1 and 2 (data layer) are complete.
	•	Story 2 increments database version to 2 (for tag tables).
	•	Story 5 (migration) increments database version to 3 (for emotionLogs table and journal entry field migration) and must be completed before Story 6 (JournalEntry updates) to ensure database schema is ready.
	•	Story 9 (EmotionLog) can prepare the repository implementation, but the table creation happens in Story 5.
	•	Each story should include minimal unit tests. Story 12 focuses on comprehensive and integration testing.
	•	The order ensures dependencies are respected: foundation → components → migration → integration → new features → comprehensive testing.
	•	Database instance sharing: The MindfullGrowthDatabase class is currently defined in journalDexieRepository.ts. Story 2 should extend this existing class. If this becomes unwieldy, the database class can be refactored to a shared module (e.g., src/db/database.ts) in a future story.

