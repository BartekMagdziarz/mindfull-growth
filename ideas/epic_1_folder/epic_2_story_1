Story 1 – Emotions Database & Domain Model

Goal

Establish the foundational emotion system by defining the Emotion domain model, creating a comprehensive seed data file with approximately 100 emotions organized by quadrant, and implementing a Pinia store (useEmotionStore) that provides access to all emotions with quadrant-based categorization. This story provides the data layer foundation that will be used by the EmotionSelector component and throughout the app for emotion tagging and logging.

⸻

Scope

1.	Emotion Domain Model
	•	Define the Emotion interface in the domain layer:
	•	Location: src/domain/emotion.ts (or similar domain file)
	•	Interface structure:
	•	id: string (UUID)
	•	name: string (e.g., "Happy", "Anxious", "Serene")
	•	pleasantness: number (1-10 scale, where 1 = very low pleasantness, 10 = very high pleasantness)
	•	energy: number (1-10 scale, where 1 = very low energy, 10 = very high energy)
	•	description?: string (optional description of the emotion)
	•	Export the Emotion interface for use across the application.

2.	Quadrant Type Definition
	•	Define the Quadrant type to represent the four quadrants of the 2×2 emotion grid:
	•	Type definition:
	•	'high-energy-high-pleasantness'
	•	'high-energy-low-pleasantness'
	•	'low-energy-high-pleasantness'
	•	'low-energy-low-pleasantness'
	•	Export the Quadrant type for use in components and stores.
	•	Implement quadrant determination logic:
	•	Create a utility function (e.g., getQuadrant(emotion: Emotion): Quadrant) that categorizes emotions into quadrants based on their pleasantness and energy values.
	•	Logic: energy > 5 and pleasantness > 5 = 'high-energy-high-pleasantness'
	•	Logic: energy > 5 and pleasantness <= 5 = 'high-energy-low-pleasantness'
	•	Logic: energy <= 5 and pleasantness > 5 = 'low-energy-high-pleasantness'
	•	Logic: energy <= 5 and pleasantness <= 5 = 'low-energy-low-pleasantness'
	•	Note: The threshold of 5 is used to split the 1-10 scale into high (6-10) and low (1-5) ranges. Consider edge cases (exactly 5) and document the decision.

3.	Emotion Seed Data File
	•	Reference: Use the emotions table file (ideas/emotions_table_idea) as the source of truth for all emotions, their pleasantness scores, energy scores, and descriptions. This file contains 100 emotions organized in a CSV-like format with all required data.
	•	Create a static seed data file containing approximately 100 emotions:
	•	Location: src/data/emotions.json (or similar data directory)
	•	Format: JSON array of emotion objects
	•	Each emotion object must include:
	•	id: string (generate UUIDs for each emotion)
	•	name: string (from emotions_table_idea)
	•	pleasantness: number (1-10, from emotions_table_idea)
	•	energy: number (1-10, from emotions_table_idea)
	•	description?: string (from emotions_table_idea, if provided)
	•	Convert the data from ideas/emotions_table_idea into the JSON format, ensuring all 100 emotions are included with their exact pleasantness and energy values.
	•	Organize emotions by quadrant (for developer reference, though the JSON can be a flat array):
	•	High Energy / High Pleasantness (~25 emotions):
	•	Examples: Ecstatic, Thrilled, Joyful, Excited, Enthusiastic, Elated, Euphoric, Jubilant, Energetic, Vibrant, Optimistic, Confident, Empowered, Triumphant, Celebratory, Amused, Playful, Cheerful, Grateful, Appreciative, Inspired, Motivated, Determined, Passionate, Zealous
	•	Pleasantness values: 7-10
	•	Energy values: 7-10
	•	High Energy / Low Pleasantness (~25 emotions):
	•	Examples: Angry, Anxious, Stressed, Frustrated, Panicked, Agitated, Irritated, Hostile, Furious, Rage, Worried, Nervous, Tense, Overwhelmed, Distressed, Restless, Hypervigilant, Jealous, Envious, Resentful, Bitter, Aggressive, Defensive, Impatient, Annoyed
	•	Pleasantness values: 1-4
	•	Energy values: 7-10
	•	Low Energy / High Pleasantness (~25 emotions):
	•	Examples: Serene, Calm, Content, Peaceful, Relaxed, Tranquil, Satisfied, Comfortable, At Ease, Placid, Mellow, Gentle, Soothing, Restful, Balanced, Grounded, Stable, Secure, Safe, Warm, Cozy, Nurtured, Supported, Appreciative, Grateful
	•	Pleasantness values: 7-10
	•	Energy values: 1-4
	•	Low Energy / Low Pleasantness (~25 emotions):
	•	Examples: Sad, Depressed, Exhausted, Lonely, Hopeless, Melancholic, Despondent, Dejected, Disheartened, Discouraged, Drained, Fatigued, Weary, Listless, Apathetic, Numb, Empty, Isolated, Abandoned, Rejected, Worthless, Ashamed, Guilty, Regretful, Remorseful
	•	Pleasantness values: 1-4
	•	Energy values: 1-4
	•	Ensure each emotion has appropriate pleasantness and energy values that align with its position in the 2×2 grid.
	•	The seed data file should be easily modifiable by developers (plain JSON, well-commented if possible, or documented separately).
	•	Consider including a few emotions near the boundaries (e.g., pleasantness=5, energy=5) to test quadrant categorization logic.

4.	Emotion Store Implementation
	•	Create a Pinia store useEmotionStore:
	•	Location: src/stores/emotion.store.ts
	•	State:
	•	emotions: Emotion[] (array holding all emotions loaded from seed data)
	•	Actions:
	•	loadEmotions(): Promise<void>
	•	Loads emotions from the seed data file (emotions.json).
	•	Parses the JSON and populates the emotions state array.
	•	Should be called on store initialization or app start.
	•	Can be idempotent (safe to call multiple times, but only loads once if already loaded).
	•	Getters:
	•	getAllEmotions(): Emotion[]
	•	Returns all emotions from the store.
	•	Returns an empty array if emotions haven't been loaded yet.
	•	getEmotionsByQuadrant(quadrant: Quadrant): Emotion[]
	•	Filters emotions based on the specified quadrant.
	•	Uses the quadrant determination logic to categorize each emotion.
	•	Returns only emotions that belong to the specified quadrant.
	•	getEmotionById(id: string): Emotion | undefined
	•	Finds and returns the emotion with the matching ID.
	•	Returns undefined if no emotion is found.
	•	Store initialization:
	•	The store should automatically load emotions when first accessed (e.g., in a setup function or on mount of a component that uses it).
	•	Alternatively, emotions can be loaded on app initialization (in main.ts or App.vue).

5.	Unit Tests
	•	Create comprehensive unit tests for the emotion store:
	•	Location: src/stores/__tests__/emotion.store.spec.ts
	•	Test cases:
	•	Store loads emotions from seed data correctly:
	•	Verify that loadEmotions() populates the emotions array.
	•	Verify that the emotions array contains approximately 100 emotions.
	•	Verify that each emotion has all required fields (id, name, pleasantness, energy).
	•	getAllEmotions() returns all emotions:
	•	Verify that getAllEmotions() returns the complete array of emotions.
	•	Verify that it returns an empty array if emotions haven't been loaded.
	•	getEmotionsByQuadrant() returns correct emotions for each quadrant:
	•	Test each of the four quadrants:
	•	'high-energy-high-pleasantness': verify all returned emotions have energy > 5 and pleasantness > 5.
	•	'high-energy-low-pleasantness': verify all returned emotions have energy > 5 and pleasantness <= 5.
	•	'low-energy-high-pleasantness': verify all returned emotions have energy <= 5 and pleasantness > 5.
	•	'low-energy-low-pleasantness': verify all returned emotions have energy <= 5 and pleasantness <= 5.
	•	Verify that each emotion appears in exactly one quadrant (no duplicates across quadrants).
	•	Verify that all emotions are accounted for across all quadrants (sum of emotions in all quadrants equals total).
	•	getEmotionById() retrieves correct emotion:
	•	Test with a valid emotion ID (should return the emotion).
	•	Test with an invalid emotion ID (should return undefined).
	•	Test with an empty string (should return undefined).
	•	Edge cases:
	•	Test quadrant determination for emotions with exactly energy=5 or pleasantness=5 (document the expected behavior).
	•	Test that the store handles empty seed data gracefully (if applicable).
	•	Use Vitest with proper setup for Pinia stores.

⸻

Acceptance Criteria

	•	The Emotion interface is defined and exported from the domain layer.
	•	The Quadrant type is defined with all four quadrant values.
	•	A quadrant determination utility function correctly categorizes emotions based on their pleasantness and energy values.
	•	The emotions.json seed data file exists and contains approximately 100 emotions organized across all four quadrants.
	•	Each emotion in the seed data has:
	•	A unique UUID.
	•	A name.
	•	Pleasantness value (1-10).
	•	Energy value (1-10).
	•	Optional description.
	•	The useEmotionStore Pinia store is implemented with:
	•	State: emotions array.
	•	Action: loadEmotions() that loads from seed data.
	•	Getters: getAllEmotions(), getEmotionsByQuadrant(), getEmotionById().
	•	The store automatically loads emotions on initialization or first access.
	•	All unit tests pass:
	•	Store loads emotions correctly.
	•	getAllEmotions() returns all emotions.
	•	getEmotionsByQuadrant() returns correct emotions for each quadrant.
	•	getEmotionById() retrieves emotions by ID correctly.
	•	No linting errors or TypeScript errors.
	•	The emotion system is ready to be used by components in subsequent stories (EmotionSelector component will depend on this).

⸻

Out of Scope

	•	UI components for displaying or selecting emotions (this is Story 3: Emotion Selector Component).
	•	Persisting emotions to IndexedDB (emotions are static seed data, not user-created).
	•	User-created custom emotions (emotion database is static for now).
	•	Emotion statistics, analytics, or insights.
	•	Integration with journal entries or emotion logs (this comes in later stories).
	•	Visual representation of the quadrant grid (this comes in Story 3).
	•	Emotion search or filtering functionality (beyond quadrant-based filtering).
	•	Emotion descriptions in UI (descriptions are optional and may be used later, but not required for this story).

⸻

Technical Notes

	•	UUID generation: Use a library like 'uuid' or 'crypto.randomUUID()' (if available in the target environment) to generate unique IDs for emotions in the seed data.
	•	Quadrant threshold: The threshold of 5 splits the 1-10 scale. Consider whether values exactly equal to 5 should be considered "high" or "low" and document the decision. A common approach is: energy > 5 = high energy, energy <= 5 = low energy (same for pleasantness).
	•	Seed data format: JSON is recommended for easy modification, but TypeScript/JavaScript files are also acceptable if they provide better type safety during development.
	•	Store initialization: Consider using Pinia's setup stores (defineStore with setup syntax) for better TypeScript support, or use the options API if the team prefers.
	•	Testing: Mock the seed data file loading in tests, or use a test-specific seed data file to ensure tests are deterministic and fast.

