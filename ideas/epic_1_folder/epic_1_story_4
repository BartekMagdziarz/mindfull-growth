Story 4 – Freeform Editor View

Goal

Implement a clean, Material Design–inspired editor for creating a single JournalEntry. This story wires the editor UI to the journal store, enabling users to create and persist journal entries through the freeform editor flow.

⸻

Scope

	1.	Route and Component Structure
	•	Route: /journal/new for creating new entries (route already exists in router, pointing to JournalNewView.vue).
	•	Note: The route currently uses JournalNewView.vue, but the epic document references JournalEditorView.vue. For consistency with existing code, we'll implement this in JournalNewView.vue. The component can be renamed later if needed, or we can consider JournalEditorView as a more descriptive name for future use (e.g., when editing existing entries via /journal/:id).
	•	Component: Update JournalNewView.vue (currently a placeholder) to implement the full editor functionality.

	2.	Layout Structure
	•	Top app bar:
	•	Enhance AppTopAppBar component to support a back button:
	•	Add an optional `showBack` prop (boolean).
	•	When `showBack` is true, display a back icon/button on the left side of the header (before the "Mindful Growth" title).
	•	The back button should use an icon (e.g., arrow-left from Heroicons) and be clickable.
	•	Emit a 'back' event when the back button is clicked, allowing the parent component to handle navigation.
	•	Alternatively, accept an optional `backRoute` prop (string) to automatically navigate when clicked.
	•	Note: The title remains "Mindful Growth" as decided in previous stories - the bottom navigation bar already indicates which view the user is in, so we don't need to change the top bar title.
	•	For JournalNewView: Use AppTopAppBar with showBack=true and handle navigation to /journal.
	•	Main content area:
	•	Title input field (Material-style text field).
	•	Body textarea (multiline, comfortable line height, full available height).
	•	Optional timestamp display (e.g., small text showing "Today, 14:32" or formatted date/time).
	•	Action buttons:
	•	Save button (filled primary variant using AppButton with variant="filled").
	•	Cancel button (text variant using AppButton with variant="text").
	•	Button placement: Use a bottom action bar (see detailed explanation in Notes section).

	3.	Material Design Input Styling
	•	Create Material Design–inspired text field styling:
	•	Rounded corners (e.g., rounded-lg or rounded-xl).
	•	Subtle outline border (using outline color token).
	•	Label above the input (floating label pattern is optional for this story; a simple label above is acceptable).
	•	Focus state: enhanced border color, subtle elevation or ring effect.
	•	Comfortable padding and line height for the textarea.
	•	Input component approach (see detailed explanation in Notes section):
	•	For this story, we'll write the input HTML directly in JournalNewView.vue and style it with Tailwind classes.
	•	Example of what this looks like in code:
	•	Instead of: <AppTextField label="Title" v-model="title" />
	•	We'll write: <input v-model="title" class="w-full px-4 py-3 rounded-lg border-2 border-outline focus:border-primary focus:ring-2..." />
	•	We're not creating a reusable AppTextField component yet (see Notes section for detailed explanation).

	4.	Component Behavior
	•	On mount (create mode):
	•	Initialize local reactive state with empty title and body.
	•	Optional: Set a default timestamp display (current date/time).
	•	On Save:
	•	Validation:
	•	At least body must not be empty (title is optional).
	•	Show user-friendly error message if validation fails (e.g., via snackbar or inline message).
	•	If valid:
	•	Call journalStore.createEntry({ title, body }).
	•	The store handles:
	•	Generating id using crypto.randomUUID().
	•	Setting createdAt and updatedAt timestamps.
	•	Persisting to IndexedDB via the repository.
	•	Adding the entry to the store's entries array.
	•	Navigate back to /journal using Vue Router.
	•	On Cancel:
	•	Navigate back to /journal without saving (using Vue Router's router.back() or router.push('/journal')).

	5.	Error Handling
	•	If journalStore.createEntry() throws an error:
	•	Display an error message to the user (e.g., via AppSnackbar).
	•	Do not navigate away if save fails.
	•	Log the error to console for debugging.
	•	Handle validation errors gracefully with clear user feedback.

	6.	User Experience Enhancements
	•	Loading state: Show a loading indicator or disable the Save button while the entry is being created.
	•	Prevent accidental navigation: Consider showing a confirmation dialog if the user tries to navigate away with unsaved changes (optional for this story, can be added later).
	•	Auto-focus: Optionally auto-focus the title input or body textarea on mount for better UX.

⸻

Acceptance Criteria

	•	AppTopAppBar component:
	•	Supports showBack prop to display a back button on the left side.
	•	Back button emits 'back' event or navigates via backRoute prop.
	•	Title remains "Mindful Growth" (unchanged from previous stories).
	•	JournalNewView.vue displays:
	•	A top app bar with a back button/icon (using enhanced AppTopAppBar with showBack=true).
	•	A title input field styled with Material Design principles (rounded, outlined, labeled).
	•	A body textarea that:
	•	Is multiline and fills available vertical space comfortably.
	•	Has appropriate line height and padding.
	•	Is styled consistently with Material Design.
	•	Optional timestamp display showing current date/time.
	•	Save and Cancel buttons styled using AppButton variants (filled and text respectively).
	•	Clicking the back button or Cancel:
	•	Navigates back to /journal without saving.
	•	Clicking Save:
	•	Validates that body is not empty.
	•	If validation fails, shows an error message.
	•	If valid, calls journalStore.createEntry({ title, body }).
	•	Navigates back to /journal after successful creation.
	•	The newly created entry appears in the JournalView list (when entries are displayed in a future story, or immediately if the list view is already implemented).
	•	Error handling:
	•	If save fails, an error message is displayed and the user remains on the editor page.
	•	Visual design:
	•	Inputs follow Material Design principles (rounded corners, subtle outline, focus states).
	•	Layout uses appropriate Material spacing tokens (via Tailwind classes).
	•	The editor is visually clean and focused on the writing experience.
	•	Linting and TypeScript checks pass (no new linting or type errors introduced).

⸻

Out of Scope

	•	Editing existing entries (route /journal/:id will be implemented in a later story).
	•	Rich text formatting or markdown support.
	•	Emotion tagging, people tags, or other metadata (will be added in later stories).
	•	Auto-save or draft functionality.
	•	Advanced confirmation dialogs for unsaved changes (can be added later if needed).
	•	Reusable AppTextField component extraction (can be done in a later story if needed).
	•	Any changes to the domain model, repository, or store (already implemented in Story 2).
	•	Note: AppTopAppBar enhancement is included in this story's scope.

⸻

Notes & Inconsistencies to Review

	1.	Component Name: The provided description mentions "JournalEditorView.vue", but the existing router already uses "JournalNewView.vue" for the /journal/new route. The epic document also references "JournalEditorView". 
	•	Decision needed: Should we rename JournalNewView.vue to JournalEditorView.vue, or keep JournalNewView.vue for now and use JournalEditorView.vue later when we add editing functionality? 
	•	Recommendation: Keep JournalNewView.vue for this story to avoid breaking existing routes. Consider JournalEditorView.vue as a more generic name when we implement editing in a future story.

	2.	Top App Bar Back Button: 
	•	Decision: Enhance AppTopAppBar to support a back button prop (showBack) only. The title remains "Mindful Growth" as decided in previous stories - the bottom navigation bar already indicates which view the user is in, so we don't need to change the top bar title. The implementation will be part of this story's scope.

	3.	Input Components: 
	•	Decision: Write the input HTML directly in JournalNewView.vue and style it with Tailwind classes, rather than creating a reusable AppTextField component.
	•	What this means in practice:
	•	In JournalNewView.vue, we'll write something like:
	•	<label class="block mb-2 text-on-surface">Title</label>
	•	<input v-model="title" class="w-full px-4 py-3 rounded-lg border-2 border-outline focus:border-primary..." />
	•	Instead of creating a separate component file like AppTextField.vue that we would use like:
	•	<AppTextField label="Title" v-model="title" />
	•	Why write it directly instead of making a component?
	•	We only need two inputs total (one title input, one body textarea) in this entire story. Creating a whole new component file, with props, styling, and logic, just for two uses is like building a whole factory to make two widgets – it's more work than it's worth.
	•	We want to see how inputs work in practice first. Maybe we'll discover we need different styles for different inputs, or maybe we'll find we need special behavior. If we create a component too early, we might design it wrong and have to change it later anyway.
	•	This follows the YAGNI principle (You Aren't Gonna Need It) – we only build reusable components when we actually need to reuse them. Right now, we're only using inputs in one place.
	•	If future stories need similar inputs (e.g., when we add editing entries, or guided journaling forms), and we find ourselves copying the same input code multiple times, THEN we'll extract it into an AppTextField component. At that point, we'll have real examples of how inputs are used, which helps us design a better component.
	•	The styling will still be consistent and Material Design–inspired, using Tailwind classes. If we need to extract it later, we can easily copy those Tailwind classes into a component.
	•	Think of it like this: You wouldn't create a special "Hammer Component" if you only need to hammer one nail. But if you're hammering nails in 10 different places, then a reusable hammer makes sense!

	4.	Button Placement: 
	•	Decision: Use a bottom action bar (not a FAB - Floating Action Button) for the Save and Cancel buttons.
	•	What's the difference?
	•	FAB (Floating Action Button): A single circular button that "floats" above the content, typically in the bottom-right corner. Material Design uses FABs for the primary action on a screen (like "Add" or "Create"). A FAB is usually just one button.
	•	Bottom Action Bar: A horizontal bar at the bottom of the screen (or content area) that can contain multiple buttons side-by-side. This is more like a toolbar.
	•	Why bottom action bar for this story:
	•	We have two buttons (Save and Cancel), not just one primary action, so a FAB doesn't fit our use case.
	•	Bottom action bars are more accessible – buttons are easier to tap, especially on mobile devices, and screen readers can navigate them more easily.
	•	Bottom action bars are common in Material Design for forms and editors (like Google Docs, Gmail compose).
	•	The buttons will be placed at the bottom of the content area, with appropriate spacing and padding. They can be in a fixed position (stays at bottom when scrolling) or at the end of the content, depending on what feels better for the editor experience.

