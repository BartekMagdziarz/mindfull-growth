Story 4 – Tag Input Components

Goal

Create reusable TagInput components that allow users to create, select, and manage people and context tags. The components display existing tags as chips, provide a text input for creating new tags, handle duplicate prevention (case-insensitive), and offer autocomplete/suggestions. These components will be used in Journal entries, Emotion logs, and (later) Exercises views.

⸻

Scope

1.	Component Structure & API
	•	Create a reusable TagInput component:
	•	Location: src/components/TagInput.vue
	•	Component API:
	•	Accepts v-model for selected tag IDs: v-model="selectedTagIds" where selectedTagIds is string[]
	•	Emits update:modelValue when selection changes
	•	Accepts a required prop tagType: 'people' | 'context' to specify which type of tags to manage
	•	Initial selection is handled via v-model (modelValue prop), following the same pattern as EmotionSelector
	•	Component should be self-contained and handle its own internal state for input and suggestions
	•	Follows Material Design principles for chips, text inputs, and autocomplete

2.	Existing Tags Display
	•	Display existing tags from useTagStore as selectable chips:
	•	For tagType="people": Display tags from tagStore.peopleTags
	•	For tagType="context": Display tags from tagStore.contextTags
	•	Tags are displayed in a grid or wrapping layout
	•	Each tag chip:
	•	Displays the tag name (e.g., "Mom", "Work Meeting")
	•	Material Design–style chip component (can use AppCard or create TagChip sub-component)
	•	Visual states:
	•	Unselected: Outlined style (e.g., outlined chip with border)
	•	Selected: Filled style (e.g., filled chip with background color)
	•	Clicking/tapping a chip toggles its selection state
	•	Users can select multiple tags
	•	Selected tags are tracked in the component's internal state and synced with v-model
	•	Tags should be loaded from the store on mount (call tagStore.loadPeopleTags() or tagStore.loadContextTags() as needed)

3.	Tag Creation via Text Input
	•	Provide a text input field for creating new tags:
	•	Input field should be clearly labeled (e.g., "Add people tag" or "Add context tag")
	•	Placeholder text: "Type to create or select a tag..."
	•	On typing and pressing Enter (or clicking an "Add" button):
	•	Trim whitespace from the input
	•	Validate that the input is not empty
	•	Check if a tag with the same name (case-insensitive) already exists
	•	If a duplicate exists:
	•	Select the existing tag (add its ID to selectedTagIds)
	•	Clear the input field
	•	If no duplicate exists:
	•	Call tagStore.createPeopleTag(name) or tagStore.createContextTag(name) based on tagType
	•	The store handles duplicate checking and creation
	•	Add the newly created tag's ID to selectedTagIds
	•	Clear the input field
	•	Error handling:
	•	If tag creation fails, show an error message (e.g., using AppSnackbar or inline error text)
	•	Do not crash the component if store operations fail

4.	Autocomplete/Suggestions
	•	As the user types in the input field:
	•	Filter existing tags (from the appropriate store) that match the input (case-insensitive partial match)
	•	Display matching tags as a dropdown or list below the input
	•	Suggestions should:
	•	Show up to 5-10 matching tags (to avoid overwhelming the UI)
	•	Highlight the matching portion of the tag name (optional, but nice UX)
	•	Allow clicking a suggestion to select that tag (adds it to selectedTagIds)
	•	Hide suggestions when:
	•	Input is empty
	•	No matches are found
	•	User clicks outside the component
	•	User selects a suggestion
	•	Keyboard navigation:
	•	Arrow keys to navigate suggestions
	•	Enter to select highlighted suggestion
	•	Escape to close suggestions

5.	Selected Tags Display
	•	Show all currently selected tags as chips:
	•	Display section: "Selected [People/Context] Tags" or similar label
	•	Layout: Horizontal scrollable row or wrapping grid of selected tag chips
	•	Each selected tag chip:
	•	Shows the tag name
	•	Has a remove/delete button (e.g., X icon, close button)
	•	Clicking the remove button deselects the tag (removes it from selectedTagIds)
	•	Visual distinction: Selected tag chips use a different style (e.g., filled, different color) than unselected chips
	•	If no tags are selected, show a placeholder message (e.g., "No tags selected")
	•	Selected tags should persist when switching between existing tags view and input mode

6.	Component Integration
	•	The component uses useTagStore:
	•	On mount, ensure tags are loaded:
	•	If tagType="people": Call tagStore.loadPeopleTags() if tags haven't been loaded
	•	If tagType="context": Call tagStore.loadContextTags() if tags haven't been loaded
	•	Use tagStore.peopleTags or tagStore.contextTags to display existing tags
	•	Use tagStore.createPeopleTag() or tagStore.createContextTag() to create new tags
	•	Use tagStore.getPeopleTagById() or tagStore.getContextTagById() to resolve tag names for selected tag IDs
	•	v-model binding:
	•	Component accepts selectedTagIds (string[]) via v-model (modelValue prop)
	•	Component watches modelValue prop to sync internal state (following EmotionSelector pattern)
	•	When user selects/deselects tags, emit update:modelValue with the updated array
	•	Component should handle edge cases:
	•	Empty tag list (if store hasn't loaded yet, show loading state)
	•	Invalid tag IDs in initial selection (ignore invalid IDs, log warning if needed)
	•	No tags exist yet (show empty state with input field available)
	•	Store loading errors (show error state, but allow user to still try creating tags)

7.	Accessibility & UX
	•	Keyboard navigation:
	•	Input field is keyboard accessible (Tab navigation, typing)
	•	Tag chips are keyboard accessible (Tab navigation, Enter/Space to toggle)
	•	Remove buttons on selected tags are keyboard accessible
	•	Autocomplete suggestions are keyboard navigable (Arrow keys, Enter to select)
	•	ARIA labels:
	•	Input field has descriptive label (e.g., "Add people tag")
	•	Tag chips have labels (e.g., "Select tag: Mom")
	•	Selected tags section has a label (e.g., "Selected people tags: 2 selected")
	•	Autocomplete dropdown has appropriate ARIA attributes
	•	Visual feedback:
	•	Hover states on interactive elements (tag chips, remove buttons, suggestions)
	•	Focus states for keyboard navigation
	•	Active/pressed states for buttons
	•	Loading states: Show a loading indicator if tags are being loaded from the store
	•	Error states: Display error messages clearly when operations fail

8.	Styling & Material Design
	•	Use existing Material Design base components where possible:
	•	AppButton for "Add" button (if used)
	•	AppCard for tag chips (or create TagChip component)
	•	Follow Material Design 3 principles:
	•	Rounded corners (consistent with app design system)
	•	Elevation/shadows where appropriate
	•	Color tokens from the app's theme (use CSS variables defined in main.css)
	•	Tag chips should be visually distinct from emotion chips (used in EmotionSelector) but follow the same design language
	•	Responsive design:
	•	Component should work on mobile (touch-friendly chip sizes, adequate spacing)
	•	Component should work on desktop (hover states, keyboard navigation)
	•	Autocomplete dropdown should be positioned correctly and not overflow viewport

9.	Minimal Tests (Unit)
	•	Add unit tests (Vitest) for TagInput component:
	•	Location: src/components/__tests__/TagInput.spec.ts
	•	Test cases:
	•	Component renders:
	•	Renders input field and existing tags as chips
	•	Each tag chip displays correct name
	•	Component accepts tagType prop and displays correct tag type
	•	Tag selection:
	•	Clicking an unselected tag chip selects it
	•	Clicking a selected tag chip deselects it
	•	Multiple tags can be selected
	•	Tag creation:
	•	Typing a new tag name and pressing Enter creates a new tag
	•	Created tag is added to selectedTagIds
	•	Input field is cleared after creation
	•	Duplicate handling:
	•	Typing a tag name that already exists (case-insensitive) selects the existing tag instead of creating a duplicate
	•	No duplicate tag is created in the store
	•	Autocomplete:
	•	Typing in input field shows matching suggestions
	•	Clicking a suggestion selects that tag
	•	Suggestions are filtered correctly (case-insensitive)
	•	Selected tags display:
	•	Selected tags appear in the "Selected Tags" section
	•	Selected tags can be removed via the remove button
	•	v-model binding:
	•	Component emits update:modelValue when tags are selected
	•	Component emits update:modelValue when tags are deselected
	•	Component accepts initial selection via modelValue prop and pre-selects those tags (v-model pattern)
	•	Store integration:
	•	Component calls tagStore.loadPeopleTags() or tagStore.loadContextTags() on mount based on tagType
	•	Component uses tagStore.createPeopleTag() or tagStore.createContextTag() to create tags
	•	Component uses tagStore.getPeopleTagById() or tagStore.getContextTagById() to resolve tag names
	•	Edge cases:
	•	Component handles empty tag list gracefully (shows loading or empty state)
	•	Component handles invalid tag IDs in initial selection (ignores them)
	•	Component handles store loading errors gracefully
	•	Use Vue Test Utils and @testing-library/vue for component testing
	•	Mock useTagStore in tests (don't hit real store implementation)

⸻

Acceptance Criteria

	•	TagInput component exists at src/components/TagInput.vue
	•	Component accepts v-model for selected tag IDs (string[])
	•	Component accepts required tagType prop ('people' | 'context')
	•	Component displays existing tags from useTagStore as selectable chips:
	•	For tagType="people": Shows tags from tagStore.peopleTags
	•	For tagType="context": Shows tags from tagStore.contextTags
	•	Users can select multiple tags by clicking chips
	•	Component provides a text input field for creating new tags
	•	On Enter or "Add" button click:
	•	Creates a new tag if it doesn't exist (case-insensitive duplicate check)
	•	Selects existing tag if duplicate is found
	•	Component provides autocomplete/suggestions as user types:
	•	Shows matching tags (case-insensitive partial match)
	•	Allows selecting suggestions via click or keyboard
	•	Selected tags are displayed in a "Selected Tags" section with remove functionality
	•	Component integrates with useTagStore:
	•	Loads tags on mount (loadPeopleTags or loadContextTags based on tagType)
	•	Uses store methods to create and retrieve tags
	•	Uses getPeopleTagById or getContextTagById to resolve tag names
	•	v-model binding works correctly:
	•	Component emits update:modelValue when selection changes
	•	Component accepts initial selection via modelValue prop (v-model pattern)
	•	Component is accessible:
	•	Keyboard navigable (Tab, Enter/Space, Arrow keys for suggestions)
	•	ARIA labels on interactive elements
	•	Focus and hover states visible
	•	Component follows Material Design principles and uses app's design system
	•	Component handles edge cases gracefully (empty states, loading states, invalid IDs, errors)
	•	All unit tests pass:
	•	Component renders correctly
	•	Tag selection works (single and multiple)
	•	Tag creation works
	•	Duplicate handling works
	•	Autocomplete works
	•	v-model binding works
	•	Store integration works
	•	Edge cases are handled
	•	No linting errors or TypeScript errors
	•	Component is ready to be used in Journal Editor and Emotion Log Editor (stories 7 and 11)

⸻

Out of Scope

	•	Emotion selector component (this is Story 3: Emotion Selector Component, which is already complete)
	•	Integration with Journal entries or Emotion logs (this comes in later stories: Story 7 for Journal, Story 11 for Emotion Logs)
	•	Tag management UI (viewing all tags, editing tag names, merging duplicates) – this will come in a later epic
	•	Tag search or filtering beyond autocomplete suggestions
	•	Bulk tag operations
	•	Tag categories or hierarchies
	•	E2E tests (they will make more sense once the component is integrated into views in later stories)
	•	Advanced animations or transitions (basic hover/focus states are sufficient)
	•	Tag chip customization (colors, sizes) beyond Material Design defaults
	•	Tag deletion from the component (tags can only be deleted via tag management UI in a future epic; this component only handles selection and creation)

⸻

Inconsistencies & Notes

	1.	Component Location:
	•	The component should be placed in src/components/TagInput.vue to match the existing component structure (AppButton, AppCard, EmotionSelector, etc. are in src/components/)
	•	This is consistent with the project structure

	2.	Store Integration:
	•	Story 2 (People & Context Tag Domain Models) has already implemented useTagStore with:
	•	peopleTags and contextTags state arrays
	•	loadPeopleTags() and loadContextTags() actions
	•	createPeopleTag(name) and createContextTag(name) actions (with duplicate handling)
	•	deletePeopleTag(id) and deleteContextTag(id) actions
	•	getPeopleTagById(id) and getContextTagById(id) getters
	•	The TagInput component will depend on this store, which is already available
	•	No inconsistencies here – the component can use the existing store implementation

	3.	Generic vs. Separate Components:
	•	The epic suggests creating either:
	•	Option A: A generic TagInput component that accepts a tagType prop ('people' | 'context')
	•	Option B: Separate components (PeopleTagInput and ContextTagInput)
	•	Recommendation: Use Option A (generic component) as it reduces code duplication and follows DRY principles. The component can switch behavior based on the tagType prop.
	•	This is consistent with the epic's suggestion: "Create a reusable TagInput component for people tags... Create a reusable TagInput component for context tags (or make it generic to handle both)"

	4.	Autocomplete Implementation:
	•	The epic mentions autocomplete/suggestions, but doesn't specify the exact UI pattern
	•	Recommendation: Implement a dropdown list that appears below the input field when the user types, showing matching tags. This is a common and accessible pattern.
	•	The autocomplete should be simple and not require external libraries (can be implemented with Vue's reactive state and computed properties)

	5.	Tag Loading Strategy:
	•	The component should load tags on mount, but the store may already have tags loaded from other components
	•	Recommendation: Check if tags are already loaded (e.g., check if peopleTags.length > 0 or use a loading flag) before calling loadPeopleTags() or loadContextTags(). This avoids unnecessary API calls.
	•	Alternatively, the store can be made idempotent (safe to call multiple times), which is likely already the case

	6.	Database & Persistence:
	•	This story does not involve database changes or persistence directly
	•	Tags are created and persisted via useTagStore, which uses the repositories implemented in Story 2
	•	The database schema (version 2 with peopleTags and contextTags tables) is already in place from Story 2
	•	No database version changes needed for this story

	7.	Component Reusability:
	•	The component is designed to be reusable across multiple views:
	•	Journal Editor (Story 7)
	•	Emotion Log Editor (Story 11)
	•	Potentially Exercises view (future epic)
	•	The v-model API and tagType prop ensure the component can be easily integrated into any parent component
	•	No inconsistencies – the design supports reusability

	8.	Testing Strategy:
	•	Unit tests should mock useTagStore to avoid dependencies on real store state
	•	Tests should verify component behavior, not store behavior (store is tested in Story 2)
	•	Integration tests (testing component + store together) can be added in Story 12 (Comprehensive Testing)
	•	This aligns with the testing strategy outlined in the epic

	9.	Story Dependencies:
	•	This story depends on Story 2 (People & Context Tag Domain Models) being complete
	•	Story 2 is complete, so this dependency is satisfied
	•	This story can be developed in parallel with Story 3 (Emotion Selector Component) once Stories 1 and 2 are complete
	•	Story 3 is already complete, so this story can proceed independently
	•	No blocking dependencies for this story

	10.	Potential Inconsistency: Tag Deletion:
	•	The epic mentions that tags can be deleted, but Story 2 implements deletePeopleTag and deleteContextTag in the store
	•	However, the TagInput component is focused on selection and creation, not deletion
	•	The epic's "Out of Scope" section for this story explicitly states: "Tag management UI (viewing all tags, editing tag names, merging duplicates) – this will come in a later epic"
	•	This is consistent – tag deletion will be handled in a future tag management UI, not in the TagInput component
	•	The TagInput component only handles removing tags from the selection (deselecting), not deleting them from the database
	•	No inconsistency here – the component's scope is clear

	11.	Initial Selection via v-model:
	•	The epic mentions "Optionally accepts initial selection via props" but doesn't specify the exact prop name
	•	Story 3 (EmotionSelector) uses modelValue prop for v-model binding and watches it to sync internal state
	•	Resolution: Follow the same pattern as EmotionSelector – use modelValue prop for v-model and watch it to sync internal state. No separate initialSelection prop is needed, as v-model handles initial values through the modelValue prop.
	•	This is consistent with Vue 3's v-model pattern and matches the EmotionSelector implementation
	•	The story has been updated to reflect this pattern

	12.	Component Naming:
	•	The epic refers to "Tag Input Components" (plural), suggesting either multiple components or a generic component
	•	Based on the recommendation to use a generic component with tagType prop, the component should be named TagInput.vue (singular)
	•	This is consistent with other component naming (EmotionSelector.vue, AppButton.vue, etc.)

