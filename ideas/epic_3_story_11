Story 11 – Polish & Documentation

Goal

Bring the LLM-powered journal chat feature to a production-ready level by polishing the UI/UX, refining copy and error messages, adding helpful in-app guidance, and updating documentation. This story focuses on making the experience feel cohesive, delightful, and easy to understand for users and maintainable for developers, without adding new core functionality.

⸻

Scope

	1.	UI & Visual Polish
	•	Perform a visual pass on all chat-related views to ensure consistency with the rest of the app:
	•	Views to review:
	•	`JournalEditorView.vue` – Chat button, dropdown, and any chat-related indicators or sections.
	•	`ChatView.vue` (or `JournalChatView.vue`) – Overall layout, message bubbles, entry context header, buttons.
	•	`JournalView.vue` – Chat indicators/badges on entries.
	•	`ProfileView.vue` – AI settings / API key section.
	•	Alignment & spacing:
	•	Use consistent padding and margins between cards, sections, and buttons (e.g., multiples of 4/8px).
	•	Check vertical rhythm: headings → body text → buttons should have consistent spacing across screens.
	•	Ensure chat message bubbles have comfortable padding, rounded corners, and consistent spacing between messages.
	•	Colors & theming:
	•	Verify all chat-related UI elements use the existing design tokens (e.g., background, surface, outline, on-surface colors).
	•	Ensure selected/active states (e.g., for chat indicators or selected chat sessions) use the same highlight colors as elsewhere in the app.
	•	Make sure the Chat button and chat badges visually fit with other primary/secondary actions.
	•	Typography:
	•	Use consistent heading sizes for titles (e.g., top app bar titles, section headings).
	•	Ensure body text, helper text, and error text use the correct font sizes and weights defined by the design system.
	•	Make AI vs user messages visually distinct via typography (e.g., slightly different weight or color) in addition to bubble styling.
	•	Responsiveness:
	•	Test chat UI on small screens (mobile) and larger screens (desktop/tablet).
	•	Ensure content does not overflow horizontally; messages should wrap correctly and remain readable.
	•	Check that bottom input area in chat view remains usable when the on-screen keyboard is open on mobile.
	•	Animations and transitions (light polish only):
	•	Optionally add subtle transitions for dropdown opening/closing and snackbar/toast appearances.
	•	Ensure any animations are short and do not interfere with accessibility (no excessive motion).

	2.	Microcopy & Error Messages
	•	Review all user-facing text related to the chat feature to ensure it is:
	•	Clear – avoids jargon and explains concepts simply (e.g., "thinking traps", "chat intentions").
	•	Empathetic – tone is supportive, non-judgmental, and aligned with the app's mental-wellbeing goals.
	•	Consistent – uses consistent terms and phrasing across views.
	•	Areas to review:
	•	Chat button label and tooltip/ARIA label (e.g., "Chat" vs "Chat about this entry").
	•	Chat intention descriptions in the dropdown.
	•	Custom prompt dialog labels and placeholder text.
	•	Error messages from LLM service: missing API key, invalid API key, network error, rate limit, generic API errors.
	•	Validation messages (e.g., empty entry body, empty custom prompt, no messages to save).
	•	Snackbar/Toast messages after saving or discarding conversations.
	•	Copy guidelines:
	•	Prefer second person ("you") and plain language.
	•	Avoid clinical-sounding language (no diagnoses or medical terminology).
	•	Explain next steps when errors occur (e.g., "Please check your API key in Profile settings.").
	•	Ensure messages are short enough to be readable on mobile without wrapping into many lines.
	•	Implementation details:
	•	Extract repeated strings into a shared constants file (e.g., `src/constants/chatCopy.ts`) where it improves consistency.
	•	Add inline comments for any copy that has specific tone requirements or rationale.

	3.	Help Text, Tooltips & In-App Guidance
	•	Add subtle, non-intrusive guidance to help users understand and confidently use the chat feature:
	•	Journal Editor – Chat entry point:
	•	Add helper text or a small info line near the Chat button (or in the dropdown) that briefly explains what the chat does (e.g., "Chat with AI to reflect on this entry and explore different perspectives.").
	•	Optionally add a tooltip on hover/focus for the Chat button with a concise explanation.
	•	Chat intention dropdown:
	•	Ensure each intention has a short, helpful description that clarifies when to use it.
	•	Consider adding a one-sentence explanation at the top of the dropdown like "Choose what you’d like help with for this entry."
	•	Custom prompt dialog:
	•	Provide a clear prompt label and placeholder with concrete examples of custom prompts.
	•	Add helper text clarifying that the AI will use both the custom prompt and the journal entry as context.
	•	Chat view:
	•	Add a short one-time info line or subtle banner near the top of the chat (or above the entry context) explaining the general behavior of the AI (e.g., "The assistant will ask gentle, reflective questions and never give clinical diagnoses.").
	•	Consider a small hint near the input area such as "Ask a question about your entry or share what you’d like to explore next."
	•	Profile view – API key:
	•	Ensure the AI Settings section includes clear help text about:
	•	Why the API key is needed.
	•	How it is stored (high-level, non-technical explanation).
	•	A reminder that keys should not be shared with others.
	•	Implementation details:
	•	Add tooltips using existing tooltip or popover components if available; otherwise, reuse existing patterns for helper text.
	•	Ensure tooltips are accessible (keyboard focusable, screen-reader friendly).
	•	Prefer help text that can be hidden or unobtrusive rather than modal walkthroughs or tours.

	4.	Accessibility & Interaction Polish
	•	Refine accessibility and interaction details identified in earlier stories to ensure the feature is comfortable to use for everyone:
	•	Keyboard navigation:
	•	Verify that:
	•	Chat button and dropdown can be fully used with keyboard only (Tab / Shift+Tab, Enter, Esc, arrow keys).
	•	Chat input, message list, and action buttons ("Save conversation", "Leave without saving") can be reached and activated by keyboard in a logical order.
	•	Confirmation dialogs (e.g., discard confirmation) trap focus correctly and return focus to a reasonable element when closed.
	•	Screen reader support:
	•	Add/verify ARIA labels and roles for:
	•	Chat button (e.g., `aria-label="Start chat about this journal entry"`).
	•	Dropdown menu and menu items (role="menu", role="menuitem").
	•	Chat messages (announce sender and content; consider `aria-label` or visually hidden labels).
	•	Chat indicators/badges (e.g., "2 chats saved for this entry").
	•	Confirmation dialogs and buttons.
	•	Ensure that important state changes (e.g., errors, successful save, chat discarded) are announced via existing snackbar component or ARIA live regions.
	•	Color & contrast:
	•	Verify that chat bubbles, buttons, badges, and text meet WCAG contrast guidelines against the background.
	•	Adjust shades (using existing palette tokens) if necessary to improve readability, especially in dark mode (if supported).
	•	Interaction feedback:
	•	Ensure all clickable elements have clear hover/focus styles.
	•	Confirm that loading states (e.g., sending message, saving conversation) are clearly communicated visually and, when possible, to screen readers.

	5.	Documentation & Developer Notes
	•	Consolidate and update developer-facing documentation so future contributors can easily understand and extend the chat feature:
	•	High-level feature overview:
	•	Add or update a section in the main project documentation (e.g., `README.md` or `docs/`) describing:
	•	The goal of the LLM-powered journal chat.
	•	Core user flows (start chat, send messages, save/discard conversation, view chat history).
	•	Limitations (no clinical advice, no streaming, no multi-provider support).
	•	Technical design:
	•	Document how the following pieces fit together:
	•	`llmService` / OpenAI integration and its responsibilities.
	•	`useChatStore` – how chat sessions are created, updated, and saved.
	•	`ChatSession` domain model and how it attaches to `JournalEntry`.
	•	Relevant views (`JournalEditorView`, `ChatView`, `JournalView`, `ProfileView`) and their roles in the feature.
	•	Configuration & environment:
	•	Document any environment variables or configuration required for using the OpenAI API (if applicable).
	•	Explain how and where the API key is stored (IndexedDB user settings) and any security considerations.
	•	Testing:
	•	Summarize the tests that cover the chat feature:
	•	Where unit tests for LLM service, chat store, and prompts live.
	•	Where integration tests for full chat flows live.
	•	How to run the relevant test suites locally.
	•	Contributor notes:
	•	Add short guidelines for extending chat functionality (e.g., adding new intentions, adjusting prompts) and where to do that safely.
	•	Clarify any deliberate trade-offs (e.g., no streaming, non-encrypted local key storage) and where they are documented.

	6.	Final Code Cleanup & Review
	•	Perform a final code review and cleanup pass across all chat-related modules and tests:
	•	Dead code & TODOs:
	•	Remove unused imports, variables, and components introduced during development of Stories 1–10.
	•	Resolve or remove outdated `TODO` and `FIXME` comments where possible; if something must remain, ensure it has clear context and is tracked elsewhere (e.g., backlog).
	•	Consistency:
	•	Ensure naming conventions for chat-related files, functions, and types are consistent (e.g., `ChatSession`, `ChatIntention`, `startChatSession`, `saveChatSession`).
	•	Align folder structure with existing conventions (e.g., domain, services, stores, views).
	•	Check that TypeScript types and interfaces are exported and reused instead of duplicated.
	•	Logging:
	•	Remove any temporary `console.log`/`console.error` statements that are no longer needed.
	•	Ensure remaining logs are purposeful and not noisy (and avoid logging sensitive data).
	•	Tests & linting:
	•	Run all unit, component, and integration tests to confirm they still pass after polish changes.
	•	Run linting and formatting and fix any new issues introduced by this story.
	•	Small refactors (only where safe):
	•	Simplify overly complex functions related to chat (e.g., long handlers in views) where it improves readability without changing behavior.
	•	Add or refine comments in non-obvious sections of code to help future maintainers understand the intent.

⸻

Acceptance Criteria

	•	UI & Visual Polish:
	•	All chat-related views (`JournalEditorView`, `ChatView`, `JournalView`, `ProfileView`) visually match the app’s design language (spacing, colors, typography).
	•	Chat message bubbles are visually distinct for user vs AI and remain readable on small and large screens.
	•	There are no obvious visual glitches such as misaligned buttons, overlapping text, or horizontal scrolling in normal use.
	•	Microcopy & Error Messages:
	•	All chat-related copy is clear, empathetic, and consistent across views.
	•	Error messages are actionable and tell users what they can do to resolve the issue (especially for API key and network problems).
	•	Repeated phrases are centralized where appropriate to reduce divergence in future changes.
	•	Help Text & Guidance:
	•	Chat entry points (Chat button, dropdown, custom prompt dialog, chat view, Profile AI settings) include concise helper text or tooltips where needed.
	•	Users can understand, without external documentation, what the chat feature does and how to start/use a conversation.
	•	Help text does not feel intrusive and does not block normal workflows.
	•	Accessibility & Interaction:
	•	Keyboard navigation works end-to-end for all chat flows (starting chat, selecting intention, sending messages, saving/discarding, viewing chat history).
	•	Screen readers can identify key elements (buttons, messages, indicators, dialogs) with meaningful labels.
	•	Contrast of chat-related UI elements meets accessibility guidelines in both light and dark themes (if applicable).
	•	Documentation:
	•	Project documentation includes an overview of the chat feature, core flows, and technical architecture.
	•	Developers can discover where to configure the LLM service, where chat sessions are stored, and how to run chat-related tests.
	•	Any known limitations or trade-offs are documented in a visible place.
	•	Code Cleanup:
	•	No leftover debug logs or temporary code related to chat.
	•	Tests and linting pass with no new errors.
	•	Chat-related code is reasonably clean and consistent, with no obvious duplication or confusing naming.
	•	The feature feels production-ready when used end-to-end by a test user.

⸻

Out of Scope

	•	Adding new core features to the chat system (e.g., streaming responses, editing messages, regenerating replies, multi-provider support).
	•	Building full user-facing tutorials, walkthroughs, or multi-step onboarding flows (beyond simple in-app hints/help text).
	•	Implementing full localization or translation of copy (this story assumes a single language, typically English).
	•	Significant redesign of non-chat parts of the app (only chat-related areas are polished here).
	•	Deep performance tuning beyond what is required to support a smooth, responsive experience in normal usage.

⸻

Technical Considerations

	•	Design system alignment:
	•	Reuse existing spacing, typography, and color tokens instead of introducing new ad-hoc values.
	•	If new tokens are absolutely necessary for chat (e.g., a specific bubble color), add them in a central theme/config file rather than inline.
	•	Accessibility:
	•	Ensure any added tooltips, banners, or hints do not break keyboard navigation or screen reader flow.
	•	When adjusting colors for contrast, verify impact in both light and dark mode and update tokens consistently.
	•	Copy management:
	•	Centralize critical repeated copy (e.g., common error messages) in a shared module to avoid divergence.
	•	Keep view-specific microcopy close to the components when it benefits readability and context.
	•	Documentation location:
	•	Follow existing project conventions for documentation (e.g., `docs/` directory, `README` sections).
	•	Link related docs together (e.g., from a general architecture doc to a chat-specific doc).
	•	Testing:
	•	Polish changes should not reduce test coverage; instead, they may require updates to assertions (e.g., updated copy, ARIA labels).
	•	Where new behavior is introduced (e.g., new helper text, tooltips that appear on focus), add or update tests to cover them.

⸻

Implementation Notes

	•	Files likely to be touched (names based on previous stories; adjust as needed to match actual paths):
	•	Views:
	•	`src/views/JournalEditorView.vue` – Chat button UI, dropdown, any chat history entry points.
	•	`src/views/ChatView.vue` or `src/views/JournalChatView.vue` – Chat interface layout, messages, input, save/discard actions.
	•	`src/views/JournalView.vue` – Chat indicators/badges and access to existing sessions.
	•	`src/views/ProfileView.vue` – AI settings / API key section help text and layout.
	•	Logic & copy:
	•	`src/services/llmService.ts` (or `openaiService.ts`) – Error messages and developer-facing comments.
	•	`src/stores/chat.store.ts` – Any error messages or logs surfaced to the UI.
	•	`src/domain/chatSession.ts` and related config (e.g., `chatPrompts.ts`) – Descriptions or notes about intentions, if needed.
	•	Documentation:
	•	Main `README.md` or `docs/` files describing the chat feature.
	•	Potential new doc file such as `docs/chat-feature.md` or similar.
	•	Process:
	•	Start with a quick visual/manual UX review of the full chat flow to gather a list of polish tasks.
	•	Implement small, focused changes one area at a time (UI, copy, accessibility, docs) to avoid regressions.
	•	After changes, run the existing test suites and perform a final manual pass of the key user flows.


