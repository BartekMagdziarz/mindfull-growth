Story 2 – Journal Domain Model, Repository & Pinia Store

Goal

Define the initial JournalEntry domain model and implement a local-first persistence layer (IndexedDB-based) plus a Pinia store to manage journal entries. This story prepares the data layer that the Journaling UI will use in later stories.

⸻

Scope
	1.	JournalEntry Type Definition
	•	Create a TypeScript interface for a journal entry in a dedicated domain/model file (e.g. src/domain/journal.ts):

export interface JournalEntry {
  id: string;        // UUID
  createdAt: string; // ISO timestamp
  updatedAt: string; // ISO timestamp
  title?: string;
  body: string;
  // Emotion tags, people, and other metadata will be added in later stories.
}


	2.	Repository Interface
	•	Define a repository interface to abstract persistence, e.g. src/repositories/journalRepository.ts:

export interface JournalRepository {
  getAll(): Promise<JournalEntry[]>;
  getById(id: string): Promise<JournalEntry | undefined>;
  create(
    data: Omit<JournalEntry, "id" | "createdAt" | "updatedAt">
  ): Promise<JournalEntry>;
  update(entry: JournalEntry): Promise<JournalEntry>;
  delete(id: string): Promise<void>;
}


	•	This interface should be independent of any specific storage technology.

	3.	IndexedDB-backed Repository Implementation
	•	Implement a concrete JournalRepository using IndexedDB via Dexie, in a file such as src/repositories/journalDexieRepository.ts.
	•	Responsibilities:
	•	Initialize the IndexedDB database and store/table for journal entries.
	•	Implement all methods from JournalRepository:
	•	getAll() returns all entries (unsorted; sorting will be handled at the store level via a getter).
	•	create():
	•	Accepts title and body.
	•	Generates id using `crypto.randomUUID()` (browser-native API, no external library needed).
	•	Sets createdAt and updatedAt to the current time (ISO string using `new Date().toISOString()`).
	•	update():
	•	Updates title, body, and updatedAt.
	•	delete():
	•	Removes the entry by id.
	•	Ensure the implementation is resilient to:
	•	Initial database creation.
	•	Schema versioning (at least stubbed for future migrations).
	•	Error handling: If IndexedDB fails to initialize or operations fail, throw errors that can be caught and handled gracefully by the store (don't crash the app silently).
	4.	Pinia Store for Journal Entries
	•	Create a Pinia store useJournalStore in src/stores/journal.store.ts:
	•	State:
	•	entries: JournalEntry[]
	•	isLoading: boolean
	•	error: string | null
	•	Getters:
	•	sortedEntries: Computed getter that returns entries sorted by createdAt descending (newest first).
	•	Actions:
	•	loadEntries():
	•	Sets isLoading true.
	•	Loads entries from the repository.
	•	Populates entries in state.
	•	Sets isLoading false on completion.
	•	On error: sets error state and logs to console; does not crash the app.
	•	createEntry(payload: { title?: string; body: string }):
	•	Calls repository.create(payload).
	•	Pushes the returned entry into entries.
	•	updateEntry(entry: JournalEntry):
	•	Calls repository.update(entry).
	•	Updates the corresponding entry in entries.
	•	deleteEntry(id: string):
	•	Calls repository.delete(id).
	•	Removes the entry from entries.
	•	Repository injection:
	•	For simplicity, directly import the Dexie repository implementation in the store (e.g. `import { journalDexieRepository } from '@/repositories/journalDexieRepository'`).
	•	A factory pattern can be added later if needed for testing flexibility, but direct import is recommended for now to keep things straightforward.
	5.	Initial Load Behavior
	•	Implement initial load strategy:
	•	Call journalStore.loadEntries() when the JournalView is mounted (preferred for this story).
	•	This keeps data loading scoped to the view that needs it.
	•	Error handling:
	•	If IndexedDB is unavailable or fails to initialize:
	•	Log errors to the console for debugging.
	•	Set the store's error state appropriately.
	•	Display a user-friendly message in the UI (e.g., "Unable to load journal entries. Please refresh the page.").
	•	Do not crash the app – the view should still render, showing an error state instead of breaking.
	•	App-level loading can be considered later if needed, but view-level loading is simpler to start with.
	6.	Minimal Tests (Unit)
	•	Add unit tests (Vitest) for useJournalStore:
	•	Creating an entry:
	•	Sets id, createdAt, and updatedAt.
	•	Appends the entry to entries.
	•	Loading entries:
	•	Populates entries based on data returned from the repository.
	•	Deleting an entry:
	•	Removes it from entries.
	•	Use a mocked repository implementation for tests (no need to hit real IndexedDB in unit tests).

⸻

Acceptance Criteria
	•	JournalEntry interface is defined and used consistently in the repository and store.
	•	A JournalRepository interface exists and describes the required methods.
	•	A concrete IndexedDB-backed repository implementation:
	•	Can create, read, update, and delete entries.
	•	Generates IDs and timestamps on creation.
	•	useJournalStore:
	•	Maintains an in-memory list of entries.
	•	Provides loadEntries, createEntry, updateEntry, and deleteEntry actions.
	•	Exposes a sortedEntries getter that returns entries sorted by createdAt descending (newest first).
	•	Successfully populates entries from the repository on loadEntries().
	•	The app can be started and:
	•	journalStore.loadEntries() executes without throwing unhandled errors.
	•	If any entries exist in IndexedDB, they are loaded into state.
	•	If IndexedDB fails, the app shows an error state but does not crash.
	•	Unit tests for useJournalStore pass.
	•	Linting and TypeScript checks pass with no new errors.

⸻

Out of Scope
	•	Any UI changes to JournalView beyond what was implemented in Story 1 (still just a placeholder at this point).
	•	Freeform editor UI and navigation.
	•	Emotion tags, filters, or any other metadata on journal entries.
	•	E2E tests (they will make more sense once UI is wired up in later stories).
